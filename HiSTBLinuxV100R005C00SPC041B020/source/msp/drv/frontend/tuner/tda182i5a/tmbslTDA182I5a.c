/*
  Copyright (C) 2012 NXP B.V., All Rights Reserved.
  This source code and any compilation or derivative thereof is the proprietary
  information of NXP B.V. and is confidential in nature. Under no circumstances
  is this software to be  exposed to or placed under an Open Source License of
  any type without the expressed written permission of NXP B.V.
 *
 * \file          tmbslTDA182I5a.c
 *
 *                %version:%
 *
 * \date          %modify_time%
 *
 * \author        Michael VANNIER
 *                
 *
 * \brief         Describe briefly the purpose of this file.
 *
 * REFERENCE DOCUMENTS :
 *                TDA182I5a_Driver_User_Guide.pdf
 *
 *
 * \section info Change Information
 *
*/

/*============================================================================*/
/* Standard include files:                                                    */
/*============================================================================*/
#include <linux/delay.h>
#include <linux/semaphore.h>

#include "linux/kernel.h"

#include <hi_debug.h>
#include "tmNxTypes.h"
#include "tmCompId.h"
#include "tmFrontEnd.h"
#include "tmbslFrontEndTypes.h"

/*============================================================================*/
/* Project include files:                                                     */
/*============================================================================*/
#include "tmbslTDA182I5a.h"

#include "tmbslTDA182I5a_RegDef.h"
#include "tmbslTDA182I5a_Local.h"
#include "tmbslTDA182I5a_Instance.h"
#include "tmbslTDA182I5a_InstanceCustom.h"


/*============================================================================*/
/* Static internal functions:                                                 */
/*============================================================================*/
static tmErrorCode_t iTDA182I5a_VCOselection(pTDA182I5aObject_t pObj);
static tmErrorCode_t iTDA182I5a_ReadThermo (pTDA182I5aObject_t pObj, UInt8* puThermo);
static tmErrorCode_t iTDA182I5a_ReadallFVCO(pTDA182I5aObject_t   pObj);
static tmErrorCode_t iTDA182I5a_ReadFVCO(pTDA182I5aObject_t   pObj, UInt8 VCOnum, UInt8 VCOfreq);
static tmErrorCode_t iTDA182I5a_CalculateNIntKInt( pTDA182I5aObject_t pObj, UInt32* NInt, UInt32* KInt);

/*============================================================================*/
/* Static variables:                                                          */
/*============================================================================*/

typedef struct _TDA182I5a_Code_Lu_def_
{
    UInt16  gnd;
    UInt16  feed;
} TDA182I5a_Code_Lu_def;

/* Table that maps LO vs Prescaler & PostDiv values */
static TDA182I5a_Code_Lu_def  Code_Lu[131] =
{
{0, 0}, /* index 0*/
{0, 1},
{1, 0},
{1, 1},
{2, 2},
{2, 4}, /* index 5*/
{4, 4},
{3, 3},
{5, 5},
{6, 6},
{6, 7}, /* index 10*/
{7, 7},
{11, 11},
{13, 13},
{14, 14},
{14, 15}, /* index 15*/
{15, 15},
{15, 23},
{23, 27},
{27, 29},
{29, 30}, /* index 20*/
{31, 31},
{31, 47},
{47, 55},
{55, 59},
{62, 62}, /* index 25*/
{63, 63},
{63, 95},
{95, 111},
{111, 119},
{125, 125}, /* index 30*/
{127, 127},
{127, 191},
{191, 223},
{223, 239},
{251, 251}, /* index 35*/
{255, 255},
{380, 380},
{381, 379},
{438, 442},
{444, 444}, /* index 40*/
{443, 443},
{446, 446},
{486, 490},
{490, 492},
{491, 493}, /* index 45*/
{494, 504},
{502, 502},
{506, 508},
{507, 507},
{510, 510}, /* index 50*/
{511, 511},
{761, 761},
{763, 759},
{877, 885},
{889, 889}, /* index 55*/
{887, 887},
{893, 893},
{973, 981},
{981, 985},
{983, 987}, /* index 60*/
{989, 1009},
{1005, 1005},
{1013, 1017},
{1015, 1015},
{1021, 1021}, /* index 65*/
{1023, 1023},
{1523, 1523},
{1527, 1519},
{1755, 1771},
{1779, 1779}, /* index 70*/
{1775, 1775},
{1787, 1787},
{1947, 1963},
{1963, 1971},
{1967, 1975}, /* index 75*/
{1979, 2019},
{2011, 2011},
{2027, 2035},
{2031, 2031},
{2043, 2043}, /* index 80*/
{2047, 2047},
{3047, 3047},
{3055, 3039},
{3511, 3543},
{3559, 3559}, /* index 85*/
{3551, 3551},
{3575, 3575},
{3895, 3927},
{3927, 3943},
{3935, 3951}, /* index 90*/
{3959, 4039},
{4023, 4023},
{4055, 4071},
{4063, 4063},
{4087, 4087}, /* index 95*/
{4095, 4095},
{0, 2},
{0, 3},
{1, 2},
{1, 3}, /* index 100*/
{2, 3},
{2, 5},
{2, 6},
{3, 5},
{3, 7},/* index 105*/
{5, 11},
{5, 7},
{7, 11},
{13, 23},
{13, 15},/* index 110*/
{15, 27},
{23, 29},
{27, 31},
{27, 30},
{29, 31},/* index 115*/
{6, 11},
{7, 14},
{7, 15},
{14, 23},
{14, 27},/* index 120*/
{15, 29},
{29, 47},
{30, 31},
{31, 55},
{47, 59},/* index 125*/
{55, 62},
{62, 63},
{63, 111},
{95, 119},
{111, 125}/* index 130*/
};

typedef struct _TDA182I5a_FilterRFDef_
{
    UInt32 LO_upto;
    UInt8 Code_Lu_index[32];
} TDA182I5a_FilterRFDef;

static TDA182I5a_FilterRFDef TDA182I5a_FilterRF[154] =
{
{ 48000 , {69, 70, 69, 70, 72, 73, 72, 74, 75, 76, 76, 77, 78, 79, 79, 80, 81, 81, 82, 82, 82, 83, 83, 84, 84, 84, 85, 85, 86, 86, 87, 87} },
{ 48922 , {68, 69, 68, 70, 70, 70, 71, 73, 74, 75, 74, 76, 77, 78, 78, 79, 79, 80, 81, 81, 82, 81, 82, 83, 83, 84, 84, 84, 85, 85, 86, 86} },
{ 49861 , {68, 68, 68, 68, 69, 70, 70, 71, 73, 73, 74, 75, 76, 76, 77, 78, 78, 79, 80, 80, 81, 82, 82, 82, 82, 83, 83, 83, 84, 85, 85, 85} },
{ 50818 , {67, 67, 67, 67, 69, 69, 69, 71, 72, 73, 73, 74, 75, 76, 76, 77, 77, 78, 79, 79, 80, 80, 81, 82, 82, 82, 82, 83, 83, 84, 84, 84} },
{ 51794 , {66, 67, 67, 67, 68, 69, 68, 70, 71, 72, 73, 73, 74, 74, 75, 76, 76, 77, 78, 78, 79, 79, 80, 81, 81, 82, 82, 82, 82, 83, 83, 83} },
{ 52789 , {65, 65, 66, 67, 66, 68, 69, 69, 70, 69, 71, 72, 73, 73, 74, 75, 75, 76, 76, 77, 78, 78, 79, 79, 80, 81, 81, 82, 82, 82, 82, 82} },
{ 53802 , {64, 64, 65, 66, 67, 67, 68, 67, 69, 70, 70, 71, 72, 72, 73, 74, 74, 75, 76, 76, 77, 77, 78, 79, 79, 80, 80, 81, 81, 81, 81, 81} },
{ 54835 , {63, 63, 64, 65, 66, 66, 67, 68, 68, 69, 69, 70, 71, 71, 72, 73, 73, 74, 74, 75, 76, 76, 77, 77, 78, 79, 79, 80, 80, 80, 80, 80} },
{ 55888 , {61, 62, 63, 64, 65, 65, 66, 67, 67, 68, 69, 69, 70, 70, 71, 71, 72, 73, 73, 74, 75, 75, 76, 76, 77, 78, 78, 79, 79, 79, 79, 79} },
{ 56961 , {61, 61, 62, 63, 64, 64, 65, 66, 67, 67, 68, 68, 69, 69, 70, 71, 71, 72, 73, 73, 74, 74, 75, 76, 76, 76, 77, 78, 78, 78, 78, 78} },
{ 58055 , {59, 60, 61, 62, 63, 63, 64, 65, 65, 66, 67, 67, 68, 68, 69, 70, 70, 71, 71, 72, 73, 73, 74, 74, 75, 76, 76, 76, 77, 77, 77, 77} },
{ 59170 , {58, 59, 60, 61, 61, 62, 63, 64, 64, 65, 66, 67, 67, 68, 68, 69, 69, 70, 70, 71, 71, 72, 73, 73, 74, 74, 75, 76, 76, 76, 76, 76} },
{ 60306 , {58, 58, 59, 60, 61, 61, 62, 63, 63, 64, 65, 65, 66, 67, 67, 68, 68, 69, 69, 70, 70, 71, 72, 72, 73, 73, 74, 74, 75, 75, 75, 75} },
{ 61464 , {56, 57, 58, 59, 59, 60, 61, 61, 62, 63, 64, 64, 65, 66, 66, 67, 68, 68, 69, 69, 70, 70, 70, 71, 72, 73, 73, 74, 74, 74, 74, 74} },
{ 62644 , {55, 56, 57, 58, 58, 59, 60, 61, 61, 62, 63, 63, 64, 65, 65, 66, 67, 67, 68, 68, 69, 69, 70, 70, 70, 71, 72, 73, 73, 73, 73, 73} },
{ 63847 , {55, 55, 56, 56, 57, 58, 59, 59, 60, 61, 61, 62, 63, 64, 64, 65, 66, 66, 67, 67, 68, 68, 69, 69, 70, 70, 70, 71, 72, 72, 72, 72} },
{ 65073 , {54, 54, 55, 56, 56, 57, 58, 59, 59, 60, 61, 61, 62, 63, 63, 64, 64, 65, 66, 66, 67, 67, 68, 68, 69, 69, 70, 70, 70, 71, 71, 71} },
{ 66322 , {53, 53, 54, 55, 55, 56, 57, 58, 58, 59, 59, 60, 61, 61, 62, 63, 63, 64, 65, 65, 66, 67, 67, 68, 68, 68, 69, 69, 70, 70, 70, 70} },
{ 67596 , {52, 53, 53, 54, 54, 55, 56, 56, 57, 58, 59, 59, 60, 61, 61, 62, 62, 63, 64, 64, 65, 65, 66, 67, 67, 68, 68, 68, 68, 69, 69, 69} },
{ 68894 , {51, 52, 52, 53, 54, 54, 55, 55, 56, 57, 58, 58, 59, 59, 60, 61, 61, 62, 63, 63, 64, 64, 65, 66, 66, 67, 67, 67, 68, 68, 68, 68} },
{ 70216 , {50, 51, 51, 52, 53, 53, 54, 55, 55, 56, 56, 57, 58, 58, 59, 60, 61, 61, 61, 62, 63, 63, 64, 64, 65, 66, 66, 67, 67, 67, 67, 67} },
{ 71565 , {49, 49, 50, 51, 52, 52, 53, 54, 54, 55, 55, 56, 57, 58, 58, 59, 59, 60, 61, 61, 62, 62, 63, 64, 64, 65, 65, 66, 66, 66, 66, 66} },
{ 72939 , {48, 48, 49, 50, 51, 52, 52, 53, 53, 54, 55, 55, 56, 56, 57, 58, 58, 59, 59, 60, 61, 61, 62, 62, 63, 64, 64, 65, 65, 65, 65, 65} },
{ 74339 , {47, 47, 48, 49, 50, 50, 51, 52, 52, 53, 54, 54, 55, 55, 56, 57, 57, 58, 58, 59, 60, 60, 61, 61, 62, 63, 63, 64, 64, 64, 64, 64} },
{ 75767 , {46, 46, 47, 48, 49, 49, 50, 51, 52, 52, 53, 53, 54, 54, 55, 56, 56, 57, 58, 58, 59, 59, 60, 61, 61, 61, 62, 63, 63, 63, 63, 63} },
{ 77221 , {45, 46, 46, 47, 48, 48, 49, 50, 51, 51, 52, 52, 53, 54, 54, 55, 55, 56, 56, 57, 58, 58, 59, 59, 60, 61, 61, 61, 62, 62, 62, 62} },
{ 78704 , {44, 44, 45, 46, 46, 47, 48, 49, 49, 50, 51, 52, 52, 53, 53, 54, 54, 55, 55, 56, 56, 57, 58, 58, 59, 59, 60, 61, 61, 61, 61, 61} },
{ 80215 , {43, 43, 44, 45, 46, 46, 47, 48, 48, 49, 50, 50, 51, 52, 52, 53, 53, 54, 55, 55, 56, 56, 57, 57, 58, 58, 59, 59, 60, 60, 60, 60} },
{ 81756 , {41, 42, 43, 44, 44, 45, 46, 47, 47, 48, 49, 49, 50, 51, 51, 52, 53, 53, 54, 54, 55, 55, 56, 56, 57, 58, 58, 59, 59, 59, 59, 59} },
{ 83325 , {41, 41, 42, 43, 44, 44, 45, 46, 46, 47, 48, 48, 49, 50, 50, 51, 52, 52, 53, 53, 54, 54, 55, 55, 56, 56, 57, 58, 58, 58, 58, 58} },
{ 84925 , {40, 40, 41, 42, 43, 43, 44, 45, 46, 46, 47, 47, 48, 49, 49, 50, 51, 51, 52, 52, 53, 53, 54, 54, 55, 55, 56, 56, 57, 57, 57, 57} },
{ 86556 , {39, 39, 40, 41, 41, 42, 43, 44, 44, 45, 46, 46, 47, 48, 48, 49, 49, 50, 51, 51, 52, 52, 53, 54, 54, 54, 55, 55, 56, 56, 56, 56} },
{ 88218 , {38, 39, 39, 40, 40, 41, 42, 43, 43, 44, 45, 45, 46, 46, 47, 48, 49, 49, 50, 50, 51, 52, 52, 53, 53, 53, 54, 54, 55, 55, 55, 55} },
{ 89912 , {37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 44, 44, 45, 46, 46, 47, 48, 48, 49, 49, 50, 51, 51, 52, 52, 53, 53, 53, 54, 54, 54, 54} },
{ 91638 , {37, 37, 37, 38, 39, 39, 40, 41, 41, 42, 43, 43, 44, 44, 45, 46, 46, 47, 48, 48, 49, 49, 50, 51, 51, 52, 52, 53, 53, 53, 53, 53} },
{ 93398 , {37, 37, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 44, 44, 45, 46, 46, 47, 47, 48, 48, 49, 50, 50, 51, 51, 52, 52, 52, 52, 52} },
{ 95191 , {36, 36, 37, 37, 37, 37, 38, 39, 39, 40, 41, 41, 42, 43, 43, 44, 44, 45, 46, 46, 47, 47, 48, 49, 49, 50, 50, 51, 51, 51, 51, 51} },
{ 97019 , {36, 36, 36, 37, 37, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 46, 47, 48, 48, 49, 49, 50, 50, 50, 50, 50} },
{ 98882 , {36, 36, 36, 36, 37, 37, 37, 37, 37, 38, 39, 39, 40, 40, 41, 42, 42, 43, 44, 44, 45, 46, 46, 46, 47, 48, 48, 49, 49, 49, 49, 49} },
{ 100780 , {35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 44, 45, 46, 46, 46, 47, 48, 48, 48, 48, 48} },
{ 102715 , {35, 35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 38, 39, 39, 40, 40, 41, 41, 42, 43, 43, 44, 44, 45, 46, 46, 47, 47, 47, 47, 47} },
{ 104688 , {35, 35, 35, 35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 39, 39, 40, 40, 41, 42, 42, 43, 43, 44, 44, 45, 46, 46, 46, 46, 46} },
{ 106698 , {34, 35, 35, 35, 35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 38, 39, 39, 40, 40, 41, 41, 42, 42, 43, 43, 44, 45, 45, 45, 45, 45} },
{ 108746 , {34, 34, 34, 35, 35, 35, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 39, 39, 40, 40, 41, 41, 42, 43, 43, 44, 44, 44, 44, 44} },
{ 110834 , {34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 38, 38, 39, 39, 40, 40, 41, 41, 42, 43, 43, 43, 43, 43} },
{ 112963 , {34, 34, 34, 34, 34, 34, 35, 35, 35, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 38, 38, 39, 39, 40, 40, 41, 41, 42, 42, 42, 42} },
{ 115132 , {33, 33, 34, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 38, 37, 39, 39, 40, 40, 41, 41, 41, 41} },
{ 117342 , {33, 33, 33, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 38, 37, 38, 40, 40, 40, 40, 40} },
{ 119595 , {32, 33, 33, 33, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39} },
{ 121892 , {32, 32, 32, 33, 33, 33, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 38, 38, 38, 38} },
{ 124232 , {32, 32, 32, 32, 33, 33, 33, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 37, 37} },
{ 126618 , {31, 32, 32, 32, 32, 32, 33, 33, 33, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37} },
{ 129049 , {31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37} },
{ 131527 , {31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 36} },
{ 134052 , {30, 31, 31, 31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36} },
{ 136626 , {30, 30, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36} },
{ 139249 , {30, 30, 30, 30, 31, 31, 31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 35} },
{ 141923 , {29, 30, 30, 30, 30, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35} },
{ 144648 , {29, 29, 29, 30, 30, 30, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35} },
{ 147426 , {29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 34} },
{ 150256 , {29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34} },
{ 153141 , {28, 28, 29, 29, 29, 29, 29, 30, 30, 30, 30, 131, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34} },
{ 156082 , {28, 28, 28, 129, 29, 29, 29, 29, 29, 30, 30, 30, 30, 131, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 34, 34} },
{ 159079 , {27, 28, 28, 28, 129, 29, 29, 29, 29, 29, 30, 30, 30, 30, 131, 131, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33} },
{ 162133 , {27, 27, 27, 28, 28, 28, 129, 29, 29, 29, 29, 29, 30, 30, 30, 30, 131, 131, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 33, 33, 33, 33} },
{ 165246 , {27, 27, 27, 27, 28, 28, 28, 129, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 131, 131, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32} },
{ 168419 , {26, 26, 27, 27, 27, 27, 28, 28, 28, 129, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 131, 131, 31, 31, 31, 31, 31, 31, 33, 32, 33, 32} },
{ 171653 , {26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 129, 29, 29, 29, 29, 29, 130, 30, 30, 30, 131, 131, 131, 31, 31, 31, 31, 31, 31, 31, 33} },
{ 174949 , {26, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 129, 129, 29, 29, 29, 29, 29, 130, 30, 30, 30, 131, 131, 131, 131, 31, 31, 31, 31, 31} },
{ 178308 , {25, 26, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 129, 129, 29, 29, 29, 29, 130, 130, 130, 30, 30, 131, 131, 131, 131, 131, 31, 31} },
{ 181732 , {25, 25, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 129, 129, 129, 29, 29, 29, 130, 130, 130, 131, 30, 131, 131, 131, 131, 131} },
{ 185221 , {25, 25, 25, 25, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 28, 28, 28, 129, 129, 129, 29, 29, 29, 29, 130, 130, 130, 131, 131, 30, 30, 30} },
{ 188778 , {24, 24, 25, 25, 25, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 129, 129, 129, 29, 130, 29, 29, 130, 130, 130, 130, 130, 130} },
{ 192402 , {24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 26, 128, 27, 27, 27, 27, 28, 28, 28, 28, 129, 129, 129, 129, 29, 130, 29, 130, 130, 130, 130} },
{ 196097 , {24, 24, 24, 24, 24, 25, 25, 25, 127, 26, 26, 26, 26, 26, 128, 128, 27, 27, 27, 28, 28, 28, 28, 129, 129, 129, 129, 129, 130, 29, 130, 29} },
{ 199862 , {23, 24, 24, 24, 24, 24, 25, 25, 25, 25, 127, 127, 26, 26, 26, 26, 128, 128, 27, 27, 27, 28, 28, 28, 28, 129, 129, 129, 129, 129, 129, 130} },
{ 203700 , {23, 23, 125, 24, 24, 24, 24, 24, 25, 25, 25, 25, 127, 127, 26, 26, 26, 26, 128, 128, 27, 27, 27, 28, 28, 28, 28, 129, 129, 129, 129, 129} },
{ 207611 , {23, 23, 23, 23, 24, 24, 24, 24, 24, 25, 25, 25, 25, 127, 127, 127, 128, 26, 26, 128, 128, 128, 128, 27, 27, 27, 28, 28, 28, 28, 28, 28} },
{ 211597 , {22, 22, 23, 23, 23, 125, 24, 24, 24, 24, 24, 25, 25, 25, 25, 127, 127, 127, 26, 26, 26, 128, 128, 128, 128, 128, 27, 27, 27, 28, 28, 28} },
{ 215660 , {22, 22, 22, 23, 23, 23, 23, 125, 24, 24, 24, 24, 24, 25, 25, 25, 25, 127, 127, 127, 26, 128, 26, 128, 128, 128, 128, 128, 128, 28, 28, 28} },
{ 219801 , {22, 22, 22, 22, 22, 23, 23, 23, 125, 125, 24, 24, 24, 24, 126, 126, 25, 25, 25, 127, 127, 127, 127, 128, 128, 128, 128, 128, 128, 128, 128, 28} },
{ 224021 , {22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 125, 125, 24, 24, 24, 24, 126, 126, 127, 25, 127, 127, 127, 127, 127, 127, 128, 26, 128, 128, 128, 128} },
{ 228323 , {21, 114, 114, 22, 22, 22, 22, 22, 23, 23, 23, 23, 125, 125, 126, 24, 24, 24, 126, 126, 127, 127, 127, 127, 127, 127, 127, 127, 26, 128, 128, 128} },
{ 232707 , {21, 21, 21, 114, 114, 22, 22, 22, 22, 22, 23, 23, 23, 125, 125, 125, 24, 126, 24, 24, 126, 126, 126, 127, 127, 127, 127, 127, 127, 127, 127, 127} },
{ 237175 , {20, 21, 21, 21, 114, 114, 116, 116, 22, 22, 22, 23, 23, 23, 23, 125, 125, 125, 125, 24, 126, 24, 126, 126, 126, 126, 127, 127, 127, 127, 127, 127} },
{ 241729 , {20, 20, 20, 21, 21, 21, 114, 114, 116, 123, 22, 22, 22, 23, 23, 23, 23, 125, 125, 125, 125, 125, 24, 126, 126, 126, 126, 126, 127, 127, 127, 127} },
{ 246371 , {19, 20, 20, 20, 21, 21, 21, 114, 114, 116, 116, 123, 123, 22, 22, 23, 23, 23, 23, 125, 125, 125, 125, 125, 126, 126, 126, 126, 126, 126, 126, 127} },
{ 251101 , {19, 19, 20, 20, 20, 20, 21, 21, 21, 114, 114, 116, 116, 123, 123, 123, 22, 23, 23, 23, 23, 125, 125, 125, 125, 125, 125, 24, 126, 126, 126, 126} },
{ 255923 , {19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 114, 114, 114, 116, 123, 123, 123, 123, 22, 22, 23, 23, 23, 125, 125, 125, 125, 125, 125, 125, 126, 126} },
{ 260836 , {19, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 114, 114, 114, 116, 123, 123, 123, 123, 123, 123, 23, 23, 23, 125, 125, 125, 125, 125, 125, 125} },
{ 265845 , {18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 114, 114, 116, 116, 123, 123, 123, 123, 123, 123, 123, 23, 23, 23, 125, 125, 125, 125} },
{ 270949 , {18, 18, 18, 112, 19, 19, 19, 19, 19, 113, 20, 20, 20, 114, 21, 21, 114, 114, 116, 116, 123, 123, 123, 123, 123, 123, 123, 23, 23, 125, 125, 125} },
{ 276152 , {17, 18, 18, 18, 18, 112, 19, 19, 19, 19, 113, 113, 20, 20, 114, 114, 114, 21, 114, 114, 116, 116, 123, 123, 123, 123, 123, 123, 123, 123, 123, 125} },
{ 281454 , {17, 17, 17, 18, 18, 18, 112, 112, 112, 19, 19, 19, 113, 113, 20, 20, 114, 114, 114, 114, 114, 114, 116, 116, 123, 123, 123, 123, 123, 123, 123, 123} },
{ 286858 , {16, 17, 17, 17, 18, 18, 18, 18, 112, 112, 112, 19, 19, 19, 113, 113, 113, 20, 114, 114, 114, 114, 114, 114, 116, 116, 123, 123, 123, 123, 123, 123} },
{ 292366 , {16, 16, 110, 17, 17, 17, 18, 18, 18, 18, 112, 112, 122, 122, 19, 19, 113, 113, 113, 113, 114, 114, 114, 114, 114, 114, 116, 116, 123, 123, 123, 123} },
{ 297980 , {16, 16, 16, 16, 110, 17, 17, 17, 18, 18, 18, 112, 112, 112, 122, 122, 19, 113, 113, 113, 113, 113, 114, 114, 114, 114, 114, 114, 114, 114, 116, 116} },
{ 303702 , {15, 16, 16, 16, 16, 16, 110, 110, 17, 18, 18, 18, 18, 112, 112, 112, 122, 122, 122, 113, 19, 113, 113, 113, 113, 113, 114, 114, 114, 114, 114, 114} },
{ 309533 , {15, 15, 16, 16, 16, 16, 16, 110, 110, 120, 120, 121, 18, 18, 18, 112, 112, 112, 122, 122, 122, 122, 113, 113, 113, 113, 113, 114, 114, 114, 114, 114} },
{ 315476 , {14, 15, 15, 15, 16, 16, 16, 16, 16, 110, 110, 120, 120, 121, 121, 112, 18, 112, 112, 112, 122, 122, 122, 122, 122, 122, 122, 122, 122, 114, 114, 114} },
{ 321534 , {14, 14, 119, 15, 15, 15, 16, 16, 16, 16, 16, 110, 110, 120, 120, 121, 121, 121, 112, 112, 112, 112, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122} },
{ 327708 , {14, 14, 14, 14, 119, 119, 15, 16, 16, 16, 16, 16, 110, 110, 110, 120, 120, 121, 121, 121, 112, 122, 112, 112, 122, 122, 122, 122, 122, 122, 122, 122} },
{ 334000 , {12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 110, 110, 110, 112, 112, 112, 112} },
{ 340413 , {12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 110, 110, 110, 110, 110} },
{ 346949 , {11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16} },
{ 353611 , {11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 16, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16} },
{ 360401 , {11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 111, 111, 14, 14, 14, 16, 16, 16, 16, 16, 16, 16, 16, 16} },
{ 367321 , {11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 109, 13, 13, 13, 13, 13, 13, 13, 111, 111, 110, 110, 110, 110, 110, 110, 16, 16, 16, 16} },
{ 374374 , {10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 109, 109, 109, 109, 109, 118, 13, 13, 118, 118, 111, 111, 110, 110, 110, 110, 110, 110} },
{ 381562 , {10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 109, 109, 109, 109, 109, 118, 118, 118, 118, 118, 118, 119, 119, 119, 111, 110} },
{ 388889 , {10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 109, 109, 109, 109, 109, 118, 118, 118, 118, 118, 118, 118, 118, 118} },
{ 396356 , {9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 107, 107, 109, 109, 12, 12, 109, 109, 109, 109, 109, 118, 118, 118, 118, 118, 118, 118} },
{ 403966 , {9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 107, 107, 107, 109, 109, 109, 109, 109, 109, 109, 109, 109, 118, 118, 118, 118} },
{ 411723 , {9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 107, 107, 107, 117, 117, 118, 118, 118, 118, 118, 118, 118, 118, 118} },
{ 419628 , {9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 107, 107, 117, 117, 117, 117, 118, 118, 118, 118, 118} },
{ 427686 , {8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 107, 107, 117, 117, 117, 117, 117, 119, 119} },
{ 435898 , {8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 107, 107, 107, 117, 117, 117, 117} },
{ 444267 , {8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 107, 107, 107, 107} },
{ 452798 , {8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11} },
{ 461492 , {8, 8, 8, 8, 8, 8, 8, 8, 8, 105, 105, 9, 9, 9, 9, 9, 9, 106, 106, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11} },
{ 470353 , {7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 105, 105, 105, 105, 105, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 11, 11} },
{ 479384 , {7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 105, 105, 105, 105, 105, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106} },
{ 488589 , {6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 105, 105, 105, 105, 105, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106} },
{ 497970 , {6, 6, 6, 7, 7, 7, 7, 102, 8, 8, 8, 8, 8, 8, 8, 8, 8, 104, 105, 105, 105, 105, 105, 106, 106, 106, 106, 106, 106, 106, 106, 106} },
{ 507532 , {5, 6, 6, 6, 6, 7, 7, 7, 7, 102, 102, 102, 103, 103, 103, 103, 104, 104, 104, 104, 106, 105, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106} },
{ 517277 , {5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 102, 102, 102, 103, 103, 103, 103, 103, 104, 104, 104, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106} },
{ 527209 , {5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 102, 102, 102, 103, 103, 103, 103, 103, 104, 104, 104, 104, 104, 104, 104, 104, 106, 106, 106} },
{ 537332 , {5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 102, 102, 102, 103, 103, 103, 103, 103, 103, 104, 104, 104, 104, 104, 104, 104, 104} },
{ 547650 , {4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 101, 101, 7, 7, 102, 102, 102, 103, 103, 103, 103, 103, 104, 104, 104, 104, 104, 104} },
{ 558165 , {4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 101, 101, 101, 101, 102, 102, 102, 103, 103, 103, 103, 103, 103, 103, 103, 103} },
{ 568882 , {4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 101, 101, 101, 101, 102, 102, 102, 102, 103, 103, 103, 103, 103, 103} },
{ 579805 , {4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 101, 101, 101, 101, 101, 102, 102, 102, 103, 103, 103, 103} },
{ 590938 , {4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 101, 101, 101, 101, 102, 102, 102, 102, 102} },
{ 602285 , {2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 101, 101, 101, 101, 101, 101, 101} },
{ 613849 , {2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 99, 99, 99, 99, 99, 99, 99, 99, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101} },
{ 625636 , {2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 99, 99, 99, 99, 99, 99, 99, 99, 99, 101, 101, 101, 101, 101, 101, 101, 101} },
{ 637649 , {2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 99, 99, 99, 99, 99, 99, 99, 99, 99, 101, 101, 101, 101, 101} },
{ 649892 , {2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99} },
{ 662371 , {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 98, 98, 98, 98, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99} },
{ 675089 , {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 98, 98, 98, 98, 98, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99} },
{ 688052 , {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 98, 98, 98, 98, 98, 98, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99} },
{ 701263 , {1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 98, 98, 98, 98, 98, 98, 99, 99, 99, 99, 99, 99, 99} },
{ 714728 , {1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 98, 98, 98, 98, 98, 98, 99, 99, 99, 99, 99} },
{ 728451 , {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 98, 98, 98, 98, 98, 98, 98, 98} },
{ 742438 , {1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 98, 98, 98, 98, 98} },
{ 756694 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2} },
{ 771223 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2} },
{ 786031 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2} },
{ 801124 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2} },
{ 816507 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2} },
{ 832184 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2} },
{ 848163 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2} },
{ 864449 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2} },
{ 881047 , {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2} }
};
typedef struct _TDA182I5a_second_order_def_
{
    Int32 x0;
    Int32 x1;
    Int32 x2;
} TDA182I5a_second_order_def;

typedef struct _TDA182I5a_max_gain_map_def_
{
    UInt32 RF;
    TDA182I5a_second_order_def eq;
} TDA182I5a_max_gain_map_def;

typedef struct _TDA182I5a_AGC1_gain_map_def_
{
    TDA182I5a_second_order_def eq;
} TDA182I5a_AGC1_gain_map_def;


static TDA182I5a_max_gain_map_def  TDA182I5a_max_gain_map[5] =
{
{0, {676620830,   651531,  -23029}},
{180, {715595090,   50258,   -1311}},
{470, {828584020,   -404406, 3361}},
{670, {791478870,   -115662, -45}},
{870, {359885240,   810542,  -4987}}
};

static TDA182I5a_max_gain_map_def  TDA182I5a_max_gain_map_all_pass[5] =
{
{0, {666881040,   660987,  -23325}},
{180, {705821030,   55897,   -1194}},
{470, {725410660,   -38963,  17}},
{670, {708903730,   28769,   -602}},
{870, {259782100,   1021625, -6099}}
};

static TDA182I5a_second_order_def  TDA182I5a_AGC1_gain_map[12] =
{
        {-327158360,  -10341,  288},
        {-299154580,  -6929,   239},
        {-269911140,  -5423,   218},
        {-240721580,  -5185,   215},
        {-210233770,  -5554,   225},
        {-179694480,  -5486,   217},
        {-149763110,  1679,    104},
        {-119898390,  739, 105},
        {-90421936,   1741,    86},
        {-61336261,   2004,    63},
        {-30850647,   676, 33},
        {0,   0,   0}
};

static TDA182I5a_second_order_def  TDA182I5a_AGC2_gain_map[142] =
{
        {-165077130,  -757,    218},
        {-163601160,  -965,    221},
        {-162618460,  -700,    218},
        {-161370440,  -970,    221},
        {-160250610,  -922,    221},
        {-158745950,  -813,    220},
        {-157859450,  -751,    219},
        {-156801430,  -682,    219},
        {-155549620,  -734,    220},
        {-154196630,  -554,    217},
        {-152819390,  -589,    218},
        {-151827800,  -651,    218},
        {-150785560,  -369,    216},
        {-149415470,  -381,    216},
        {-147947330,  -281,    215},
        {-147005180,  -326,    215},
        {-145961010,  -379,    216},
        {-144788350,  -149,    214},
        {-143305060,  -265,    215},
        {-142052270,  -197,    214},
        {-141010100,  -228,    214},
        {-139868730,  -323,    215},
        {-138621560,  -132,    213},
        {-137075890,   -42,    212},
        {-136136060,  -119,    213},
        {-135075800,   -73,    212},
        {-133876120,    41,    211},
        {-132442990,  -223,    213},
        {-131128640,  -180,    213},
        {-130161940,   -87,    212},
        {-129024000,   -61,    212},
        {-127685190,  -111,    212},
        {-126238660,    25,    210},
        {-125341710,   -53,    211},
        {-124300390,    83,    210},
        {-123056300,    33,    210},
        {-121683350,   148,    209},
        {-120368890,   140,    208},
        {-119386680,   216,    206},
        {-118240130,   216,    206},
        {-116946780,   279,    205},
        {-115470580,   386,    204},
        {-114556970,   300,    205},
        {-113515770,   244,    205},
        {-112306500,   203,    205},
        {-110865960,   170,    206},
        {-109530730,    57,    206},
        {-108631440,   487,    201},
        {-107523590,   521,    200},
        {-106250940,   594,    199},
        {-104718320,   501,    200},
        {-103824530,   596,    198},
        {-102795640,   580,    198},
        {-101589820,   554,    197},
        {-100195390,   549,    198},
        {-98871627 ,   705,    195},
        {-97929489 ,   847,    192},
        {-96826552 ,   929,    190},
        {-95506101 ,   729,    192},
        {-94010712 ,   685,    191},
        {-93180126 ,   934,    189},
        {-92160693 ,  1029,    187},
        {-90968122 ,   954,    187},
        {-89553918 ,   791,    189},
        {-88275079 ,   925,    188},
        {-87310169 ,  1035,    185},
        {-86234318 ,  1132,    183},
        {-84945138 ,  1120,    182},
        {-83511151 ,  1245,    181},
        {-82625812 ,  1210,    181},
        {-81623733 ,  1387,    178},
        {-80442133 ,  1397,    177},
        {-79092712 ,  1453,    176},
        {-77773516 ,  1558,    173},
        {-76789929 ,  1478,    172},
        {-75701892 ,  1491,    171},
        {-74393230 ,  1316,    171},
        {-72988171 ,  1556,    168},
        {-72079570 ,  1595,    166},
        {-71066217 ,  1507,    167},
        {-69900177 ,  1543,    165},
        {-68564538 ,  1578,    165},
        {-67204104 ,  1493,    162},
        {-66230791 ,  1474,    158},
        {-65141070 ,  1460,    157},
        {-63907524 ,  1588,    154},
        {-62420911 ,  1375,    156},
        {-61610740 ,  1747,    152},
        {-60577615 ,  1706,    150},
        {-59439072 ,  1775,    149},
        {-58134150 ,  1891,    149},
        {-56795656 ,  1775,    144},
        {-55820656 ,  1785,    141},
        {-54740110 ,  1799,    139},
        {-53500313 ,  1886,    136},
        {-52091935 ,  1884,    136},
        {-51218573 ,  1764,    139},
        {-50233527 ,  1793,    138},
        {-49082279 ,  1834,    136},
        {-47769173 ,  1841,    136},
        {-46456043 ,  1848,    130},
        {-45540729 ,  1973,    124},
        {-44456156 ,  1977,    122},
        {-43226642 ,  2027,    119},
        {-41805608 ,  2004,    120},
        {-40943013 ,  1960,    119},
        {-39905489 ,  1874,    116},
        {-38805277 ,  2033,    113},
        {-37485833 ,  1968,    114},
        {-36239671 ,  2062,    108},
        {-35310774 ,  1983,    104},
        {-34155912 ,  1669,    102},
        {-32988927 ,  1909,    98},
        {-31589130 ,  1897,    97},
        {-30705109 ,  1837,    95},
        {-29722691 ,  1910,    92},
        {-28526131 ,  1583,    90},
        {-27305866 ,  1965,    88},
        {-25958466 ,  1781,    83},
        {-25041089 ,  1832,    76},
        {-23985214 ,  1836,    73},
        {-22724773 ,  1577,    70},
        {-21382566 ,  1873,    67},
        {-20608718 ,  1759,    66},
        {-19625016 ,  1827,    61},
        {-18521428 ,  1854,    58},
        {-17215390 ,  1737,    57},
        {-15712679 ,  1511,    46},
        {-14214386 ,  1661,    45},
        {-13096968 ,  1326,    40},
        {-11879522 ,  1239,    36},
        {-11048423 ,  1230,    33},
        {-9964394  ,  1313,    30},
        {-8712508  ,  1038,    25},
        {-7239514  ,  1248,    23},
        {-6254854  ,   712,    17},
        {-5504964  ,   630,    14},
        {-4317758  ,   512,     9},
        {-3444512  ,   676,     7},
        {-2254271  ,   487,     5},
        {-980780   ,    53,     1},
        {0,   0,   0}
};

/*============================================================================*/
/* Exported functions:                                                        */
/*============================================================================*/

/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_Open:                                           */
/*                                                                            */
/* DESCRIPTION: Opens driver setup environment.                               */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_Open(
    tmUnitSelect_t              tUnit,      /* I: FrontEnd unit number */
    tmbslFrontEndDependency_t*  psSrvFunc   /* I: setup parameters */
)
{
    pTDA182I5aObject_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Test parameter(s) */
    if(psSrvFunc == Null)
    {
        err = TDA182I5a_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        /* Get a driver instance */
        err = iTDA182I5a_GetInstance(tUnit, &pObj);
    }

    /* Check driver instance state */
    if(err == TM_OK || err == TDA182I5a_ERR_ERR_NO_INSTANCES)
    {
        if(P_OBJ_VALID && pObj->init == True)
        {
            err = TDA182I5a_ERR_ALREADY_SETUP;
        }
        else 
        {
            if(P_OBJ_VALID == False)
            {
                /* Try to allocate an instance of the driver */
                err = iTDA182I5a_AllocInstance(tUnit, &pObj);
                if(err != TM_OK || pObj == Null)
                {
                    err = TDA182I5a_ERR_ERR_NO_INSTANCES;
                }
            }

            if(err == TM_OK)
            {
                /* Initialize the Object by default values */
                P_SIO = P_FUNC_SIO(psSrvFunc);
                P_STIME = P_FUNC_STIME(psSrvFunc);
                P_SDEBUG = P_FUNC_SDEBUG(psSrvFunc);

#ifdef _TVFE_IMPLEMENT_MUTEX
                if(    P_FUNC_SMUTEX_OPEN_VALID(psSrvFunc)
                    && P_FUNC_SMUTEX_CLOSE_VALID(psSrvFunc)
                    && P_FUNC_SMUTEX_ACQUIRE_VALID(psSrvFunc)
                    && P_FUNC_SMUTEX_RELEASE_VALID(psSrvFunc) )
                {
                    P_SMUTEX = psSrvFunc->sMutex;

                    err = P_SMUTEX_OPEN(&P_MUTEX);
                    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "Mutex_Open(0x%08X) failed.", tUnit));
                }
#endif

                tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_Open(0x%08X)", tUnit);

                if(err == TM_OK)
                {
                    pObj->init = True;
                }
            }
        }
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_Close:                                          */
/*                                                                            */
/* DESCRIPTION: Closes driver setup environment.                              */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_Close(
    tmUnitSelect_t  tUnit   /* I: FrontEnd unit number */
)
{
    pTDA182I5aObject_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA182I5a_GetInstance(tUnit, &pObj);

    if(err == TM_OK)
    {
#ifdef _TVFE_IMPLEMENT_MUTEX
        /* Try to acquire driver mutex */
        err = iTDA182I5a_MutexAcquire(pObj, TDA182I5a_MUTEX_TIMEOUT);

        if(err == TM_OK)
        {
#endif
            tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_Close(0x%08X)", tUnit);

#ifdef _TVFE_IMPLEMENT_MUTEX
            P_SMUTEX_ACQUIRE = Null;

            /* Release driver mutex */
            (void)iTDA182I5a_MutexRelease(pObj);

            if(P_SMUTEX_CLOSE_VALID && P_MUTEX_VALID)
            {
                err = P_SMUTEX_CLOSE(P_MUTEX);
            }

            P_SMUTEX_OPEN = Null;
            P_SMUTEX_CLOSE = Null;
            P_SMUTEX_RELEASE = Null;

            P_MUTEX = Null;
        }
#endif

        err = iTDA182I5a_DeAllocInstance(pObj);
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_GetSWVersion:                                   */
/*                                                                            */
/* DESCRIPTION: Gets the versions of the driver.                              */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_GetSWVersion(
    ptmSWVersion_t  pSWVersion  /* I: Receives SW Version */
)
{
    pSWVersion->compatibilityNr = TDA182I5a_COMP_NUM;
    pSWVersion->majorVersionNr  = TDA182I5a_MAJOR_VER;
    pSWVersion->minorVersionNr  = TDA182I5a_MINOR_VER;

    return TM_OK;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_GetSWSettingsVersion:                           */
/*                                                                            */
/* DESCRIPTION: Returns the version of the driver settings.                   */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_GetSWSettingsVersion(
    ptmSWSettingsVersion_t pSWSettingsVersion   /* O: Receives SW Settings Version */
)
{
    pSWSettingsVersion->customerNr      = TDA182I5a_SETTINGS_CUSTOMER_NUM;
    pSWSettingsVersion->projectNr       = TDA182I5a_SETTINGS_PROJECT_NUM;
    pSWSettingsVersion->majorVersionNr  = TDA182I5a_SETTINGS_MAJOR_VER;
    pSWSettingsVersion->minorVersionNr  = TDA182I5a_SETTINGS_MINOR_VER;

    return TM_OK;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_SetPowerState                                   */
/*                                                                            */
/* DESCRIPTION: Sets the power state.                                         */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_SetPowerState(
    tmUnitSelect_t  tUnit,      /* I: Unit number */
    tmPowerState_t  powerState  /* I: Power state */
 )
{
    pTDA182I5aObject_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA182I5a_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA182I5a)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_SetPowerState(0x%08X)", tUnit);

    if(powerState>=tmPowerMax)
    {
        err = TDA182I5a_ERR_BAD_PARAMETER;
    }
    if(err == TM_OK)
    {
        if(pObj->mapLLPowerState[powerState] != pObj->curLLPowerState)
        {
            err = iTDA182I5a_SetLLPowerState(pObj, pObj->mapLLPowerState[powerState]);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_SetLLPowerState(0x%08X, %d) failed.", tUnit, (int)pObj->mapLLPowerState[powerState]));

            if(err == TM_OK)
            {
                /* Store power state in driver instance */
                pObj->curPowerState = powerState;
            }
        }
    }

    _MUTEX_RELEASE(TDA182I5a)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_GetPowerState:                                  */
/*                                                                            */
/* DESCRIPTION: Gets the power state.                                         */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_GetPowerState(
    tmUnitSelect_t  tUnit,      /* I: Unit number */
    tmPowerState_t* pPowerState /* O: Power state */
)
{
    pTDA182I5aObject_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA182I5a_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA182I5a)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_GetPowerState(0x%08X)", tUnit);

    /* Test parameter(s) */
    if(pPowerState == Null)
    {
        err = TDA182I5a_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        *pPowerState = pObj->curPowerState;
    }

    _MUTEX_RELEASE(TDA182I5a)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_SetStandardMode                                 */
/*                                                                            */
/* DESCRIPTION: Sets the standard mode.                                       */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_SetStandardMode(
    tmUnitSelect_t          tUnit,          /* I: Unit number */
    TDA182I5aStandardMode_t  StandardMode    /* I: Standard mode of this device */
)
{
    pTDA182I5aObject_t           pObj = Null;
    tmErrorCode_t               err = TM_OK;
    UInt8 uMinor=0, uMajor=0;

    /* Get a driver instance */
    err = iTDA182I5a_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA182I5a)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_SetStandardMode(0x%08X)", tUnit);

    if((err == TM_OK) && (pObj->Std_Array[StandardMode - 1].IF !=0))
    {
        pObj->StandardMode = StandardMode;
        pObj->pStandard = &pObj->Std_Array[pObj->StandardMode - 1];
        pObj->uIF = pObj->pStandard->IF;
        pObj->SpectralInversion = pObj->pStandard->SpectralInversion;

        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_ID_byte_3__Minor_rev, &uMinor, Bus_None );
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_ID_byte_3__Major_rev, &uMajor, Bus_None );


        /****************************************************************/
        /* IF SpectralInversion Settings                                */
        /****************************************************************/

        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IR_Mixer_byte_1__hrm_swap, pObj->SpectralInversion, Bus_NoRead);

        /****************************************************************/
        /* IF SELECTIVITY Settings                                      */
        /****************************************************************/

        /* Set LPFc */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_Byte_1__LP_Fc, pObj->pStandard->LPF, Bus_None);

        /* Set LPFc Offset */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_Byte_1__IF_LPF_Offset,(UInt8)(pObj->pStandard->LPF_Offset), Bus_None);

        /* Set LPF Offset sign */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_Byte_1__IF_LPF_sign, (UInt8)(pObj->pStandard->LPF_sign), Bus_None);

        /* Set DC_Notch_IF_PPF */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_Byte_1__DC_Notch, pObj->pStandard->DC_Notch_IF_PPF, Bus_None);

        /* Set Hi Pass Enable */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_Byte_2__IF_HP_Enable, pObj->pStandard->HP_Enable, Bus_None);
        
        /* Set HP Fc  */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_Byte_2__IF_HP_Fc, pObj->pStandard->HPF, Bus_None);

        /* Set HP Offset  */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_Byte_2__IF_HPF_Offset, pObj->pStandard->HPF_Offset, Bus_None);

        /* Set HP Offset sign  */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_Byte_2__IF_HPF_sign, pObj->pStandard->HPF_sign, Bus_None);

        /* Set IF Notch Enable */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_Byte_3__IF_Notch_Enable, pObj->pStandard->IF_Notch_Enable, Bus_None);
        
        /* Set IF Notch Freq */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_Byte_3__IF_Notch_Freq, pObj->pStandard->IF_Notch_Freq, Bus_None);

        /* SetIF Notch Offset  */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_Byte_3__IF_Notch_Offset, pObj->pStandard->IF_Notch_Offset, Bus_None);

        /* Set IF Notch Offset sign  */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_Byte_3__IF_Notch_sign, pObj->pStandard->IF_Notch_sign, Bus_None);

        /* Set  IFnotchToRSSI   */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_AGC_byte__IFnotchToRSSI, pObj->pStandard->IFnotchToRSSI, Bus_None);


        /****************************************************************/
        /* AGC TOP Settings                                             */
        /****************************************************************/

        /* Set AGC1 TOP I2C DN/UP */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top, pObj->pStandard->AGC1_TOP_I2C_DN_UP, Bus_None);

        /* Set  AGC1 TOP STRATEGY  */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top_Strategy, pObj->pStandard->AGC1_TOP_STRATEGY, Bus_None);

        /* Set  AGC1_Do_step  */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_3__AGC1_Do_step, pObj->pStandard->AGC1_Do_step, Bus_None);

        /* Set  AGC2 TOP I2C DN/UP no write  */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC2_byte_1__AGC2_TOP, pObj->pStandard->AGC2_TOP_I2C_DN_UP, Bus_None);

        /* Set  AGC2 TOP STRATEGY, ! final write Reg_AGC2_byte_1  */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC2_byte_1__AGC2_Top_Strategy, pObj->pStandard->AGC2_Top_Strategy, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", tUnit));

        if(err == TM_OK)
        {

            /* Set  AGC2_Do_step  */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_RF_byte__AGC2_Do_step, pObj->pStandard->AGC2_Do_step, Bus_None);

            /* Set  AGC2_Up_step  */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGCK_byte_1__AGC2_Up_step, pObj->pStandard->AGC2_Up_step, Bus_None);

            /* Set  AGC4 TOP I2C DN/UP   */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IR_Mixer_byte_1__AGC4_TOP, pObj->pStandard->AGC4_TOP_I2C_DN_UP, Bus_None);

            /* Set  AGC4_Do_step  */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IR_Mixer_byte_2__AGC4_Do_step, pObj->pStandard->AGC4_Do_step, Bus_None);

            /* Set  AGC5 TOP I2C DN/UP   */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC5_byte_1__AGC5_TOP, pObj->pStandard->AGC5_TOP_I2C_DN_UP, Bus_None);

            /* Set  AGC5_Do_step  */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC5_byte_2__AGC5_Do_step, pObj->pStandard->AGC5_Do_step, Bus_None);

            /* Set  AGC145_Up_step  */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_2__AGC145_Up_step, pObj->pStandard->AGC145_Up_step, Bus_NoRead);

            /* Set  AGC1 TOP adapt   */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Adapt_Top_byte__Top_adapt_AGC1, pObj->pStandard->AGC1_Adapt_TOP, Bus_None);

            /* Set  AGC2 TOP adapt   */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Adapt_Top_byte__Top_adapt_AGC2, pObj->pStandard->AGC2_Adapt_TOP, Bus_None);

            /* Set  IF Output Level   ! final write Reg_IF_AGC_byte */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_AGC_byte__IF_level, pObj->pStandard->IF_Output_Level, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", tUnit));
        }
        if(err == TM_OK)
        {

            /* Set  AGC Overload TOP */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Ovld_Udld_byte__AGC_Ovld_TOP, pObj->pStandard->AGC_Overload_TOP, Bus_None);

//   FRo         /* Set  AGC2 Gain Control Speed  */
//            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_2__AGC2_Gain_Control_Speed, pObj->pStandard->AGC2_Gain_Control_Speed, Bus_None);

            /* Set  AGC1_cc_Freeze  */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_2__AGC1_cc_Freeze_Enable, (UInt8)pObj->pStandard->AGC1_cc_Freeze_Enable, Bus_None);

            /* Set  AGC1_cc_Wide  */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_2__AGC1_cc_Wide_Enable, (UInt8)pObj->pStandard->AGC1_cc_Wide_Enable, Bus_None);

            /* Set PD Vsync_Mgt  */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Vsync_byte__PD_Vsync_Mgt, pObj->pStandard->PD_Vsync_Mgt, Bus_None);

            /* Set Negative modulation  */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Vsync_byte__Neg_Modulation, pObj->pStandard->Neg_Modulation, Bus_None);

            /* Set AGCK Mode  */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGCK_byte_1__AGCK_Mode, pObj->pStandard->AGCK_Mode, Bus_None);

            /* Set AGC5_HP_Fc  */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC5_byte_1__AGC5_HP_Fc, pObj->pStandard->AGC5_HP_Fc, Bus_None);

            /* Set RSSI_HP_Fc  */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC5_byte_1__RSSI_HP_Fc, pObj->pStandard->RSSI_HP_Fc, Bus_None);

            /* Set Det6_Cap_Val   no write */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_RSSI_byte_2__Det6_Cap_Val, pObj->pStandard->Det6_Cap_Val, Bus_None);

            /* Set RSSI_AV  no write */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_RSSI_byte_2__RSSI_AV, pObj->pStandard->RSSI_AV, Bus_None);

            /* Set RSSI_Ck_Speed final write  ! final write Reg_RSSI_byte_2 */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_RSSI_byte_2__RSSI_Ck_Speed, pObj->pStandard->RSSI_Ck_Speed, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", tUnit));
        }

        /****************************************************************/
        /* AGC fast Settings                                             */
        /****************************************************************/

        if(err == TM_OK)
        {
            if (pObj->pStandard->AGC_Fast_RF_Ovld)
            {
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Ovld_Udld_byte__RF_ovld_disable, 0x00, Bus_None);
            }
            else
            {
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Ovld_Udld_byte__RF_ovld_disable, 0x01, Bus_None);
            }
            if (pObj->pStandard->AGC_Fast_RF_Udld)
            {
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Ovld_Udld_byte__RF_udld_disable, 0x00, Bus_None);
            }
            else
            {
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Ovld_Udld_byte__RF_udld_disable, 0x01, Bus_None);
            }
            if (pObj->pStandard->AGC_Fast_IF_Ovld)
            {
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Ovld_Udld_byte__IF_ovld_disable, 0x00, Bus_None);
            }
            else
            {
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Ovld_Udld_byte__IF_ovld_disable, 0x01, Bus_None);
            }
            if (pObj->pStandard->AGC_Fast_IF_Udld)
            {
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Ovld_Udld_byte__IF_udld_disable, 0x00, Bus_NoRead);
            }
            else
            {
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Ovld_Udld_byte__IF_udld_disable, 0x01, Bus_NoRead);
            }
        }
        if(err == TM_OK)
        {            
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_RF_Filters_byte_1__LNA_Highpass, pObj->pStandard->LNA_Highpass, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", tUnit));
        }
		if(err == TM_OK)
		{
            /* Set _DIFOUT_En  */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_AGC_byte__DIFOUT_En, pObj->pStandard->DIFOUT_En, Bus_None);

            /* Set  DVIFAGC_En */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_AGC_byte__DVIFAGC_En, (pObj->pStandard->DVIFAGC_En & 0x7F), Bus_NoRead);
            /* Set  VIFAGCINV_En */

            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_AGC_byte__IFAGCINV_En, (pObj->pStandard->DVIFAGC_En >> 7), Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", tUnit));
        }
		if(err == TM_OK)
		{
#ifdef DIVERSITY_POWERSAVINGMODE
            err = iTDA182I5a_Diversity_PowerSavingMode(pObj, pObj->pStandard->PowerSavingMode);
#else
			err = iTDA182I5a_PowerSavingMode(pObj, pObj->pStandard->PowerSavingMode);
#endif
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_PowerSavingMode(0x%08X) failed.", pObj->tUnitW));
		}

		/* Blocks final writting */
        if(err == TM_OK)
        {
            /* Write AGC1_byte_1, AGC1_byte_3   Registers */
            err = iTDA182I5a_WriteRegMap(pObj, gTDA182I5a_Reg_AGC1_byte_1.Address, TDA182I5a_REG_DATA_LEN(gTDA182I5a_Reg_AGC1_byte_1, gTDA182I5a_Reg_AGC1_byte_3));
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_WriteRegMap(0x%08X) failed.", pObj->tUnitW));
        }
        if(err == TM_OK)
        {
            /* Write RF_byte, AGCK_byte_1, IR_Mixer_byte_1 , IR_Mixer_byte_2 ,  AGC5_byte_1 , AGC5_byte_2 Registers */
            err = iTDA182I5a_WriteRegMap(pObj, gTDA182I5a_Reg_RF_byte.Address, TDA182I5a_REG_DATA_LEN(gTDA182I5a_Reg_RF_byte, gTDA182I5a_Reg_AGC5_byte_2));
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_WriteRegMap(0x%08X) failed.", pObj->tUnitW));
        }

        if(err == TM_OK)
        {
            /* Write Adapt_Top_byte, Vsync_byte, Ovld_Udld_byte, IF_Byte_1,  IF_Byte_2 , IF_Byte_3   Registers */
            err = iTDA182I5a_WriteRegMap(pObj, gTDA182I5a_Reg_Adapt_Top_byte.Address, TDA182I5a_REG_DATA_LEN(gTDA182I5a_Reg_Adapt_Top_byte, gTDA182I5a_Reg_IF_Byte_3));
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_WriteRegMap(0x%08X) failed.", pObj->tUnitW));
        }

        /* Update driver state machine */
        pObj->eHwState = TDA182I5a_HwState_SetStdDone;
    }
    else
    {
        err = TDA182I5a_ERR_NOT_SUPPORTED;
    }

    _MUTEX_RELEASE(TDA182I5a)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_GetStandardMode                                 */
/*                                                                            */
/* DESCRIPTION: Gets the standard mode.                                       */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_GetStandardMode(
    tmUnitSelect_t          tUnit,          /* I: Unit number */
    TDA182I5aStandardMode_t  *pStandardMode  /* O: Standard mode of this device */
)
{
    pTDA182I5aObject_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA182I5a_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA182I5a)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_GetStandardMode(0x%08X)", tUnit);

    if(pStandardMode == Null)
    {
        err = TDA182I5a_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        /* Get standard mode */
        *pStandardMode = pObj->StandardMode;
    }

    _MUTEX_RELEASE(TDA182I5a)

    return err;
}


/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_SetRF:                                          */
/*                                                                            */
/* DESCRIPTION: Tunes to a RF.                                                */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_SetRF(
    tmUnitSelect_t  tUnit,  /* I: Unit number */
    UInt32          uRF     /* I: RF frequency in hertz */
)
{
    pTDA182I5aObject_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA182I5a_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA182I5a)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_SetRF(0x%08X)", tUnit);

    /* Test parameter(s) */
    if(   pObj->StandardMode<=TDA182I5a_StandardMode_Unknown
       || pObj->StandardMode>=TDA182I5a_StandardMode_Max
       || pObj->pStandard == Null)
    {
        err = TDA182I5a_ERR_STD_NOT_SET;
    }

    if(err == TM_OK)
    {
        /* Check if Hw is ready to operate */
        err = iTDA182I5a_CheckHwState(pObj, TDA182I5a_HwStateCaller_SetRF);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_CheckHwState(0x%08X) failed.", pObj->tUnitW));
    }

    /* check range RF supported :  42 - 1002 Mhz */
    if(err == TM_OK && (uRF > 1002000000 || uRF < 42000000))
    {
        err = TDA182I5a_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        pObj->uRF = uRF;

        switch (pObj->SpectralInversion)
        {
        case TDA182I5a_hrm_swap_RF_spectrum_inversion_n_swap_I:
        case TDA182I5a_hrm_swap_RF_spectrum_inversion_n_swap_Q:
            pObj->uLO = pObj->uRF - pObj->uIF;
            break;
        case TDA182I5a_hrm_swap_No_RF_spectrum_inversion:
        case TDA182I5a_hrm_swap_No_RF_spectrum_inversion_n_both_I_and_Q_swap:
        default:
            pObj->uLO = pObj->uRF + pObj->uIF;
            break;
        }

        err = iTDA182I5a_SetRF(pObj);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_SetRF(0x%08X) failed.", tUnit));

        if(err == TM_OK)
        {
            /* Update driver state machine */
            pObj->eHwState = TDA182I5a_HwState_SetRFDone;
        }
    }

    if(err == TM_OK)
    {
        /* Update driver state machine */
        pObj->eHwState = TDA182I5a_HwState_SetRFDone;
    }

    _MUTEX_RELEASE(TDA182I5a)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_GetRF:                                          */
/*                                                                            */
/* DESCRIPTION: Gets tuned RF.                                                */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_GetRF(
    tmUnitSelect_t  tUnit,  /* I: Unit number */
    UInt32*         puRF    /* O: RF frequency in hertz */
)
{
    pTDA182I5aObject_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA182I5a_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA182I5a)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_GetRF(0x%08X)", tUnit);

    if(puRF == Null)
    {
        err = TDA182I5a_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        /* Get RF */
        *puRF = pObj->uRF;
    }

    _MUTEX_RELEASE(TDA182I5a)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_HwInit:                                         */
/*                                                                            */
/* DESCRIPTION: Initializes TDA182I5a Hardware.                                */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*   initial values needed, but ok from POR                                   */
/*    LOSD_Static_N = 1                                                       */
/*    agc1_highZ = 1                                                          */
/*    cp_cursel = 4                                                           */
/*    LO_Int = 0x72                                                           */
/*    VCO_Select = 0x02 ( VCO low)                                            */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_HwInit(
    tmUnitSelect_t  tUnit   /* I: Unit number */
)
{
    pTDA182I5aObject_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;
    UInt8 uVal=0;
    UInt32 counter = 10; /* Wait I2C ready */

    /* Get a driver instance */
    err = iTDA182I5a_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA182I5a)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_HwInit(0x%08X)", tUnit);

    /* Reset standard mode & Hw State */
    pObj->StandardMode = TDA182I5a_StandardMode_Max;
    pObj->eHwState = TDA182I5a_HwState_InitNotDone;

    /* Check I2C IC responding */
    while(counter > 0)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Test_byte__reset_i2c_dis, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", tUnit));
        if(err==TM_OK)
        {
            /* IC I2C responds */
            break;
        }
        if(counter)
        {
            /* Decrease the counter */
            counter--;

            /* Wait for a step of  1ms */
            err = iTDA182I5a_Wait(pObj, 1);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Wait(0x%08X) failed.", pObj->tUnitW));
        }
	}

    /* ensure Dig_Clock_16MHz before Digital part reset */
    if (err==TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Reference_Byte__Dig_Clock, TDA182I5a_Dig_Clock_16MHz, Bus_RW);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", tUnit));
    }

    /* perform soft reset and register set to POR  */
    if (err==TM_OK)
    {
        /* put tuner in POR state by soft reset ( state and machine and registers values */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Powerdown__force_soft_reset, 0x01, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Powerdown__Soft_reset, 0x01, Bus_NoRead);
    }

    if (err==TM_OK)
    {
        /* check POR status */
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_Power_state_byte_1__POR , &uVal, Bus_RW);
    }

    if (err==TM_OK)
    {
        err = (uVal == 1 ?  TM_OK : TDA182I5a_ERR_NOT_INITIALIZED);       
    }

    if (err==TM_OK)
    {
        /* Read all bytes */
        err = iTDA182I5a_ReadRegMap(pObj, 0x00, TDA182I5a_REG_MAP_NB_BYTES);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_ReadRegMap(0x%08X) failed.", tUnit));
    }

    /* change some POR register values */
    if (err==TM_OK)
    {
#ifdef DIVERSITY_DIG_V
        /* set digital voltage to 1.6V */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Regulators_byte__Dig_Reg, DIVERSITY_DIG_V, Bus_RW);
#endif
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Regulators_byte__VCO_Reg, TDA182I5a_VCO_Reg_2d8_nom_V, Bus_NoRead);
        /* set bit agck_step_sync */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Test_byte__agck_step_sync, 0x01, Bus_NoRead);
    }

    /* set tuner in dedicated internal power state  for calibration */
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Power_state_byte_2__power_state_mode, (UInt8)TDA182I5a_power_state_mode_Image_Rejection_mode, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", tUnit));
    }

    /* Launch RCAL & IR calibration */
    if(err == TM_OK)
    {
        err = iTDA182I5a_MSMLaunch(pObj, TDA182I5a_MSM_IR_CAL_Image|TDA182I5a_MSM_IR_Cal_Loop|TDA182I5a_MSM_RC_Cal);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_SetMSM(0x%08X, TDA182I5a_MSM_HwInit) failed.", pObj->tUnitW));
    }

    if(err == TM_OK)
    {
        /* State reached after 300 ms max ( include XTAL cal end */
        err = iTDA182I5a_WaitIRQ(pObj, 300, 10);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_WaitIRQ(0x%08X) failed.", tUnit));
    }
    /* get RCAL result memory for SETRF */
    if(err == TM_OK)
    {
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_RC_Cal_byte_2__RCcal, &uVal, Bus_NoWrite);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }

    /* launch VCO measurements Max/min */
    if(err == TM_OK)
    {
        err = iTDA182I5a_ReadallFVCO(pObj);
    }

    /* restore some settings after calibration  */
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_SigmaDelta_Test_byte__LOSD_Static_N, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", tUnit));
    }
	if(err == TM_OK)
	{
		err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Power_Down_byte_1__PD_SUBLO, 0x00, Bus_NoRead);
		tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));		
	}

	/* disable XTOUT if requested */
    if(err == TM_OK)
    {
        if ((pObj->TunerModeInUse & TDA182I5_Mode_XTOUT_Used)!= TDA182I5_Mode_XTOUT_Used)
        {
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Reference_Byte__Xtout, (UInt8)TDA182I5a_Xtout_No_signal, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", tUnit));
        }
    }

    /* set tuner POR state:  Sdtby */
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Power_state_byte_2__power_state_mode, (UInt8)TDA182I5a_power_state_mode_Standby, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", tUnit));
    }
    if(err == TM_OK)
    {
        pObj->curLLPowerState = TDA182I5a_PowerStandby;
        pObj->curPowerState = tmPowerStandby;
    }
    _MUTEX_RELEASE(TDA182I5a)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_GetIF:                                          */
/*                                                                            */
/* DESCRIPTION: Gets programmed IF.                                           */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_GetIF(
    tmUnitSelect_t  tUnit,  /* I: Unit number */
    UInt32*         puIF    /* O: IF Frequency in hertz */
)
{
    pTDA182I5aObject_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA182I5a_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA182I5a)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_GetIF(0x%08X)", tUnit);

    /* Test parameter(s) */
    if(   pObj->StandardMode<=TDA182I5a_StandardMode_Unknown
        || pObj->StandardMode>=TDA182I5a_StandardMode_Max
        || pObj->pStandard == Null
        || puIF == Null)
    {
        err = TDA182I5a_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        switch (pObj->SpectralInversion)
        {
        case TDA182I5a_hrm_swap_RF_spectrum_inversion_n_swap_I:
        case TDA182I5a_hrm_swap_RF_spectrum_inversion_n_swap_Q:
            *puIF = pObj->uRF - pObj->uLO;
            break;
        case TDA182I5a_hrm_swap_No_RF_spectrum_inversion:
        case TDA182I5a_hrm_swap_No_RF_spectrum_inversion_n_both_I_and_Q_swap:
        default:
            *puIF = pObj->uLO - pObj->uRF;
            break;
        }
    }

    _MUTEX_RELEASE(TDA182I5a)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_GetLockStatus:                                  */
/*                                                                            */
/* DESCRIPTION: Gets PLL Lock Status.                                         */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_GetLockStatus(
    tmUnitSelect_t          tUnit,      /* I: Unit number */
    tmbslFrontEndState_t*   pLockStatus /* O: PLL Lock status */
)
{
    pTDA182I5aObject_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;
    UInt8               uValue = 0, uValueLO = 0;

    /* Get a driver instance */
    err = iTDA182I5a_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA182I5a)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_GetLockStatus(0x%08X)", tUnit);

    if( pLockStatus == Null )
    {
        err = TDA182I5a_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_Power_state_byte_1__LO_Lock, &uValueLO, Bus_RW);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Read(0x%08X) failed.", pObj->tUnitW));

        if(err == TM_OK)
        {
            err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_IRQ_status__IRQ_status, &uValue, Bus_RW);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Read(0x%08X) failed.", pObj->tUnitW));
        }

        if(err == TM_OK)
        {
            uValue = uValue & uValueLO;

            *pLockStatus =  (uValue)? tmbslFrontEndStateLocked : tmbslFrontEndStateNotLocked;
        }
        else
        {
            *pLockStatus = tmbslFrontEndStateUnknown;
        }
    }

    _MUTEX_RELEASE(TDA182I5a)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_GetPowerLevel:                                  */
/*                                                                            */
/* DESCRIPTION: Gets HW Power Level.   1/2 steps dBuV                         */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_GetPowerLevel
(
    tmUnitSelect_t  tUnit,      /* I: Unit number */
    UInt8*          pPowerLevel /* O: Power Level in 1/2 steps dBuV */
)
{
    pTDA182I5aObject_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;
    UInt8  Val = 0, uIndex = 0, loop = 0, IFnotchToRSSI= 1;
    UInt16  det6 = 0;
    Int32 AGC4_gain_map[5] = {-117110000, -88050000, -58960000, -29510000, 0};
    Int32 AGC5_gain_map[8] = {-207260000, -178400000, -147930000, -118040000, -87780001, -58500001, -29090001, 0};
    Int32 iRF=0;
    Int32 atten_max=0, atten_agc1=0, atten_agc2=0, atten_agc4=0, atten_agc5=0, atten_hpf=0;
    Int32 TDA182I5a_AGC2_Highpass_gain_map[5][5] =  /* HPF index / RF index */
    { 
      {-106270000,   -62530000,   -18650001,    -6690000,    -290001},
      { -80400000,   -41070000,    -8020001,    -1140001,    1520000},
      { -51930000,   -20590000,     -560001,     2139999,    2109999},
      { -27230000,    -7570000,     1190000,     1680000,    1139999},
      {0, 0, 0, 0, 0}
    };
    Int32 Atten_standard[19] = {0,1500000, 16300000, -14100000, -3500000, 0, -3500000, 16200000, 16500000, 0, 16500000, \
     /*                            QAM6      QAM8       ATSC      ISDBT  D1.7   D6         D7       D8    D10    DMBT */
       0, -75600000, -106600000, -59500000, -55500000, -60500000, -78500000, -161600000};
    /*FM      MN         B         GH           I         DK         L         LL */


    /* Get a driver instance */
    err = iTDA182I5a_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA182I5a)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_GetPowerLevel_Calibrated(0x%08X)", tUnit);

    /* Check IFnotToRSSI */
    err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_IF_AGC_byte__IFnotchToRSSI, &IFnotchToRSSI, Bus_RW);

    if (IFnotchToRSSI == 0)
    {
        /* disable IF_UDLD/OVLD */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Ovld_Udld_byte__IF_udld_disable, 0x01, Bus_NoRead);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Ovld_Udld_byte__IF_ovld_disable, 0x01, Bus_NoRead);

        /* switch IFnotToRSSI */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_AGC_byte__IFnotchToRSSI, 0x01, Bus_NoRead);

        /* wait 1ms */
        err = iTDA182I5a_Wait(pObj, 1);
    }

    /* Test parameter(s) */
    if( pPowerLevel == Null ||
        pObj->StandardMode<=TDA182I5a_StandardMode_Unknown ||
        pObj->StandardMode>=TDA182I5a_StandardMode_Max ||
        pObj->pStandard == Null)
    {
        err = TDA182I5a_ERR_BAD_PARAMETER;
    }
    /* get average det6_level to avoid spread */
    for (loop=0; loop<16; loop++)
    {
        if(err == TM_OK)
        {
            err = iTDA182I5a_Wait(pObj, 1);
        }
        if(err == TM_OK)
        {
            /* Read Power Level 1/2 dB */
            err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_Power_Level_byte_1__Det6_level, &Val, Bus_RW);
            det6 = det6 + Val;
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Read(0x%08X) failed.", tUnit));
        }
    }
    det6 = det6 >> 4; /* round min  average over 16 samples */
    /* MaxGain(freq) contribution */
    if(err == TM_OK)
    {
        iRF=pObj->uRF/1000000;
        while ( (UInt32)iRF > (TDA182I5a_max_gain_map[uIndex].RF )  && uIndex < 5)
            uIndex = uIndex + 1;
        if (pObj->uLUCodeProgrammed==0)  /* all pass RPF */
        {
            atten_max = TDA182I5a_max_gain_map_all_pass[uIndex-1].eq.x0  +  (TDA182I5a_max_gain_map_all_pass[uIndex-1].eq.x1 * iRF)  + (TDA182I5a_max_gain_map_all_pass[uIndex-1].eq.x2 / 10 * iRF * iRF);
        }
        else
        {
            atten_max = TDA182I5a_max_gain_map[uIndex-1].eq.x0  +  (TDA182I5a_max_gain_map[uIndex-1].eq.x1 * iRF)  + (TDA182I5a_max_gain_map[uIndex-1].eq.x2 / 10 * iRF * iRF);
        }
    }

    /* AGC1(freq) contribution */
    if(err == TM_OK)
    {
	    err =  iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_AGC1_Gain_byte__AGC1_Gain_Read, &Val, Bus_NoWrite);
    }
    if(err == TM_OK)
    {        
        atten_agc1 = TDA182I5a_AGC1_gain_map[Val].x0 +  (TDA182I5a_AGC1_gain_map[Val].x1 * iRF) + ((TDA182I5a_AGC1_gain_map[Val].x2 * iRF * iRF)/10);
    }

    /* AGC2(freq) contribution */
    if(err == TM_OK)
    {
	    err =  iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_AGC2_Gain_byte__AGC2_Gain_Read, &Val, Bus_NoWrite);
    }
    if(err == TM_OK)
    {
        atten_agc2 = TDA182I5a_AGC2_gain_map[Val].x0 + (TDA182I5a_AGC2_gain_map[Val].x1 * iRF) + ((TDA182I5a_AGC2_gain_map[Val].x2 * iRF * iRF)/10);
    }

    /* AGC4(freq) contribution */
    if(err == TM_OK)
    {
	    err =  iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_IFAGCs_Gain_byte__AGC4_Gain_Read, &Val, Bus_NoWrite);
    }
    if(err == TM_OK)
    {
        atten_agc4 = AGC4_gain_map[(Val>4)? 4:Val];
    }

    /* AGC5(freq) contribution */
    if(err == TM_OK)
    {
	    err =  iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_IFAGCs_Gain_byte__AGC5_Gain_Read, &Val, Bus_None);
        atten_agc5 = AGC5_gain_map[Val];
    }

    /* AGC2_Highpass(freq) contribution */
    if(err == TM_OK)
    {
	    err =  iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_RF_Filters_byte_1__AGC2_Highpass, &Val, Bus_NoWrite);
    }
    if(err == TM_OK)
    {
        if (iRF< 180)
        {
            atten_hpf = TDA182I5a_AGC2_Highpass_gain_map[Val][0] + ((TDA182I5a_AGC2_Highpass_gain_map[Val][1] - TDA182I5a_AGC2_Highpass_gain_map[Val][0]) / 80 * (iRF - 100)  );
        }
        else if (iRF< 400)
        {
            atten_hpf = TDA182I5a_AGC2_Highpass_gain_map[Val][1] + ((TDA182I5a_AGC2_Highpass_gain_map[Val][2] - TDA182I5a_AGC2_Highpass_gain_map[Val][1]) / 220 * (iRF - 180));
        }
        else if (iRF< 600)
        {
            atten_hpf = TDA182I5a_AGC2_Highpass_gain_map[Val][2] + ((TDA182I5a_AGC2_Highpass_gain_map[Val][3] - TDA182I5a_AGC2_Highpass_gain_map[Val][2]) / 200 * (iRF - 400));
        }
        else
        {
            atten_hpf = TDA182I5a_AGC2_Highpass_gain_map[Val][3] + ((TDA182I5a_AGC2_Highpass_gain_map[Val][4] - TDA182I5a_AGC2_Highpass_gain_map[Val][3]) / 400 * (iRF - 600));
        }
    }
    atten_max = atten_max + atten_agc1 + atten_agc2 + atten_agc4 + atten_agc5 + atten_hpf + Atten_standard[pObj->StandardMode];
    atten_max = atten_max /5000000;  /* 1/2 dB 10^7 */

    *pPowerLevel = (UInt8)(det6 - atten_max);

    if (IFnotchToRSSI == 0)
    {
        /* switch back IFnotToRSSI */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IF_AGC_byte__IFnotchToRSSI, 0x00, Bus_NoRead);

        /* wait 1ms */
        err = iTDA182I5a_Wait(pObj, 1);

        /* enable IF_UDLD/OVLD */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Ovld_Udld_byte__IF_udld_disable, 0x00, Bus_NoRead);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Ovld_Udld_byte__IF_ovld_disable, 0x00, Bus_NoRead);
    }

    _MUTEX_RELEASE(TDA182I5a)

    return err;
}
/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_GetThermo:                                      */
/*                                                                            */
/* DESCRIPTION: returns IC temperature in  C                                 */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_GetThermo(
    tmUnitSelect_t  tUnit,      /* I: Unit number */
    UInt8*          pThermo     /* O: temperature in C */
)
{
    pTDA182I5aObject_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA182I5a_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA182I5a)
    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_GetThermo(0x%08X)", tUnit);

    err = iTDA182I5a_ReadThermo(pObj, pThermo);
    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_ReadThermo(0x%08X) failed.", pObj->tUnitW));
   
    _MUTEX_RELEASE(TDA182I5a)

    return err;
}
/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_SetFineRF:                                      */
/*                                                                            */
/* DESCRIPTION: Fine tunes RF with given step.                                */
/*              (tmbslTDA182I5a_SetRF must be called before calling this API)  */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_SetFineRF(
    tmUnitSelect_t  tUnit,  /* I: Unit number */
    Int8            step    /* I: step (-1, +1) */
)
{
    pTDA182I5aObject_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    UInt8 i = 0;
    UInt8 uLoChain_ratio=0;

    /* Get a driver instance */
    err = iTDA182I5a_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA182I5a)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_SetFineRF(0x%08X)", tUnit);

    /* Test parameter(s) */
    if(   pObj->StandardMode<=TDA182I5a_StandardMode_Unknown
        || pObj->StandardMode>=TDA182I5a_StandardMode_Max
        || pObj->pStandard == Null)
    {
        err = TDA182I5a_ERR_STD_NOT_SET;
    }

    if(err == TM_OK)
    {
        /* Check if Hw is ready to operate */
        err = iTDA182I5a_CheckHwState(pObj, TDA182I5a_HwStateCaller_SetFineRF);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_CheckHwState(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_LoChain_byte__LoChain_ratio, &uLoChain_ratio, Bus_None);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }

    if(err == TM_OK)
    {
        /* Write the offset into 4 equal steps of 15.625 KHz = 62.5 KHz*/
        for (i=0; i < 4; i++)
        {
            /* Calculate wanted LO = RF + IF and FVCO */
            pObj->uRF += step*15625;
            pObj->uFVCO = (pObj->uFVCO/(pObj->uLO /1000)) * ((pObj->uLO + step*15625)/1000) ;
            pObj->uLO += step*15625;
            
            /* Calculate N & K values of the PLL */
            err = iTDA182I5a_SetPLL(pObj);
        }

        /* Update driver state machine */
        pObj->eHwState = TDA182I5a_HwState_SetFineRFDone;
    }

    _MUTEX_RELEASE(TDA182I5a)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA18275_SetFineRF_Step:                                 */
/*                                                                            */
/* DESCRIPTION: Fine tunes RF with given step.                                */
/*              (tmbslTDA18275_SetRF must be called before calling this API)  */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_SetFineRF_Step(
    tmUnitSelect_t  tUnit,  /* I: Unit number */
    Int32           step_val  /* signed step value  in hz */
)
{
    pTDA182I5aObject_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;
    UInt8 uLoChain_ratio=0;

    /* Get a driver instance */
    err = iTDA182I5a_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA182I5a)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_SetFineRF(0x%08X)", tUnit);

    /* Test parameter(s) */
    if(   pObj->StandardMode<=TDA182I5a_StandardMode_Unknown
        || pObj->StandardMode>=TDA182I5a_StandardMode_Max
        || pObj->pStandard == Null)
    {
        err = TDA182I5a_ERR_STD_NOT_SET;
    }

    if(err == TM_OK)
    {
        /* Check if Hw is ready to operate */
        err = iTDA182I5a_CheckHwState(pObj, TDA182I5a_HwStateCaller_SetFineRF);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_CheckHwState(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_LoChain_byte__LoChain_ratio, &uLoChain_ratio, Bus_None);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }

    if(err == TM_OK)
    {
        /* Calculate wanted LO = RF + IF and FVCO */
        pObj->uRF += step_val;
        pObj->uFVCO = (pObj->uFVCO/(pObj->uLO /1000)) * ((pObj->uLO + step_val)/1000) ;
        pObj->uLO += step_val;

        /* Calculate N & K values of the PLL */
        err = iTDA182I5a_SetPLL(pObj);
    }

    /* Update driver state machine */
    pObj->eHwState = TDA182I5a_HwState_SetFineRFDone;

    _MUTEX_RELEASE(TDA182I5a)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_Write                                           */
/*                                                                            */
/* DESCRIPTION: Writes in TDA182I5a hardware                                   */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_Write(
    tmUnitSelect_t              tUnit,      /* I: Unit number */
    const TDA182I5a_BitField_t*  pBitField,  /* I: Bitfield structure */
    UInt8                       uData,      /* I: Data to write */
    tmbslFrontEndBusAccess_t                eBusAccess  /* I: Access to bus */
)
{
    pTDA182I5aObject_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA182I5a_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA182I5a)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_Write(0x%08X)", tUnit);

    err = iTDA182I5a_Write(pObj, pBitField, uData, eBusAccess);
    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));

    _MUTEX_RELEASE(TDA182I5a)

    return err;
}

/*============================================================================*/
/* FUNCTION:    tmbslTDA182I5a_Read                                            */
/*                                                                            */
/* DESCRIPTION: Reads in TDA182I5a hardware                                    */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
tmbslTDA182I5a_Read(
    tmUnitSelect_t              tUnit,      /* I: Unit number */
    const TDA182I5a_BitField_t*  pBitField,  /* I: Bitfield structure */
    UInt8*                      puData,     /* I: Data to read */
    tmbslFrontEndBusAccess_t                eBusAccess  /* I: Access to bus */
)
{
    pTDA182I5aObject_t   pObj = Null;
    tmErrorCode_t       err = TM_OK;

    /* Get a driver instance */
    err = iTDA182I5a_GetInstance(tUnit, &pObj);

    _MUTEX_ACQUIRE(TDA182I5a)

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_Read(0x%08X)", tUnit);

    err = iTDA182I5a_Read(pObj, pBitField, puData, eBusAccess);
    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Read(0x%08X) failed.", pObj->tUnitW));

    _MUTEX_RELEASE(TDA182I5a)

    return err;
}

/*============================================================================*/
/* Internal functions:                                                        */
/*============================================================================*/

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_GetIdent                                       */
/*                                                                            */
/* DESCRIPTION: get HW indentity                                              */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_GetIdent(
    pTDA182I5aObject_t       pObj,   /* I: Driver object */
    UInt16*          puIdentity, /* O: tuner Ident */
    UInt8*           puMajorRev, /* O:  Major rev */
    UInt8*           puMinorRev  /* O: Minor rev */
)
{
    tmErrorCode_t       err = TM_OK;
    UInt8 Ident1, Ident2;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "tmbslTDA182I5a_GetIdent(0x%08X)", pObj->tUnitW);

    if(err == TM_OK)
    {
        err |= iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_ID_byte_1__Ident_1, &Ident1, Bus_NoWrite );
        err |= iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_ID_byte_2__Ident_2, &Ident2, Bus_NoWrite );
        * puIdentity = ((Ident1 & 0x7F) << 8) + Ident2;
        err |= iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_ID_byte_3__Minor_rev, puMinorRev, Bus_NoWrite );
        err |= iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_ID_byte_3__Major_rev, puMajorRev, Bus_NoWrite );
    }

    return err;
}
/*============================================================================*/
/* FUNCTION:    iTDA182I5a_CheckHwState                                        */
/*                                                                            */
/* DESCRIPTION: Checks if Hw is ready to operate.                             */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_CheckHwState(
    pTDA182I5aObject_t       pObj,   /* I: Driver object */
    TDA182I5aHwStateCaller_t caller  /* I: Caller API */
)
{
    tmErrorCode_t   err = TM_OK;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_CheckHwState(0x%08X)", pObj->tUnitW);

    switch(pObj->eHwState)
    {
        case TDA182I5a_HwState_InitNotDone:
            switch(caller)
            {
                case TDA182I5a_HwStateCaller_SetPower:
                    break;

                default:
                    err = TDA182I5a_ERR_NOT_INITIALIZED;
                    break;
            }
            break;

        case TDA182I5a_HwState_InitDone:
            switch(caller)
            {
                case TDA182I5a_HwStateCaller_SetRF:
                case TDA182I5a_HwStateCaller_SetFineRF:
                    /* SetStandardMode API must be called before calling SetRF and SetFineRF */
                    err = TDA182I5a_ERR_STD_NOT_SET;
                    break;

                default:
                    break;
            }
            break;

        case TDA182I5a_HwState_SetStdDone:
            switch(caller)
            {
                case TDA182I5a_HwStateCaller_SetFineRF:
                    /* SetRF API must be called before calling SetFineRF */
                    err = TDA182I5a_ERR_RF_NOT_SET;
                    break;

                default:
                    break;
            }
            break;

        case TDA182I5a_HwState_SetRFDone:
        case TDA182I5a_HwState_SetFineRFDone:
            break;

        case TDA182I5a_HwState_InitPending:
            err = TDA182I5a_ERR_NOT_READY;
            break;            
        default:
            err = TDA182I5a_ERR_NOT_READY;
            break;
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_SetLLPowerState                                     */
/*                                                                            */
/* DESCRIPTION: Sets the power state.                                         */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_SetLLPowerState(
    pTDA182I5aObject_t       pObj,       /* I: Driver object */
    TDA182I5aPowerState_t    powerState  /* I: Power state of TDA182I5a */
)
{
    tmErrorCode_t   err = TM_OK;
    TDA182I5a_power_state_mode_t hwpowerstate;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_SetLLPowerState(0x%08X)", pObj->tUnitW);

    if (pObj->curLLPowerState != powerState)
    {      

        if(err == TM_OK)
        {
            switch(powerState)
            {
            case TDA182I5a_PowerNormalMode:
                    hwpowerstate = TDA182I5a_power_state_mode_Normal;
                    if (pObj->TunerModeInUse & TDA182I5_Mode_LTO_Used) /* LT on */
                    {
                        /* keep Loop Through active */
                        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Power_Down_byte_1__PD_LT, 0x00, Bus_NoRead);
                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
                    }
                    else /* LT off */
                    {
                        /* Power down Loop Through */
                        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Power_Down_byte_1__PD_LT, 0x01, Bus_NoRead);
                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
                    }
                    err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Power_state_byte_2__power_state_mode, (UInt8)hwpowerstate, Bus_NoRead);
                    if(err == TM_OK)
                    {
                        /* disable HighZ LNA */
                        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__LNA_HiZ, 0x00, Bus_NoRead);
                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
                    }
                break;
            default: /* all standby modes */
                    if (pObj->TunerModeInUse & TDA182I5_Mode_LTO_Used) /* LT on */
                    {
                        hwpowerstate = TDA182I5a_power_state_mode_Standby_p_LT;
                        /* disable HighZ LNA */
                        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__LNA_HiZ, 0x00, Bus_NoRead);
                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
                        /* keep Loop Through active */
                        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Power_Down_byte_1__PD_LT, 0x00, Bus_NoRead);
                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
                        /* Set digital clock mode to 16 Mhz before entering standby */
                        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Reference_Byte__Dig_Clock, TDA182I5a_Dig_Clock_16MHz, Bus_NoRead);
                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
                        /* Set AGC1 top*/
                        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top, TDA182I5a_AGC1_Top_104_98_dBuVrms, Bus_None);
                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
                        /* Set AGC1 top strategy*/
                        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top_Strategy, TDA182I5a_AGC1_Top_Strategy_No_dynamic_TOP_change, Bus_NoRead);
                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
                    }
                    else /* LT off */
                    {
                        hwpowerstate = TDA182I5a_power_state_mode_Standby;
                        /* enable HighZ LNA */
                        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__LNA_HiZ, 0x01, Bus_NoRead);
                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
                        /* Set digital clock mode to 16 Mhz before entering standby */
                        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Reference_Byte__Dig_Clock, TDA182I5a_Dig_Clock_16MHz, Bus_NoRead);
                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
                    }

                    if(err == TM_OK)
                    {
                        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Power_state_byte_2__power_state_mode, (UInt8)hwpowerstate, Bus_NoRead);
                        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
                    }
                break;
            }
        }

        if(err == TM_OK)
        {
            /* Store low-level power state in driver instance */
            pObj->curLLPowerState = powerState;
        }
    }

    return err;
}
/*============================================================================*/
/* FUNCTION:    iTDA182I5a_ReadThermo:                                         */
/*                                                                            */
/* DESCRIPTION: activate & read Thermo                                        */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
static tmErrorCode_t
iTDA182I5a_ReadThermo(
    pTDA182I5aObject_t   pObj,    /* I: Driver object */
    UInt8*            puThermo  /* O: temperature read */
    )
{
    tmErrorCode_t   err = TM_OK;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_ReadThermo(0x%08X)", pObj->tUnitW);

    err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Thermo_byte_2__TM_ON, 0x01, Bus_NoRead );
    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    if(err == TM_OK)
    {
        err = iTDA182I5a_Read(pObj,&gTDA182I5a_Reg_Thermo_byte_1__TM_D, puThermo, Bus_NoWrite);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Read(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Thermo_byte_2__TM_ON, 0x00, Bus_NoRead );
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }

    return err;
}
/*============================================================================*/
/* FUNCTION:    iTDA182I5a_ReadFVCO   :                                        */
/*                                                                            */
/* DESCRIPTION: launch all VCO measure                                        */
/*                                                                            */
/*                                                                            */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
static tmErrorCode_t
iTDA182I5a_ReadallFVCO(
    pTDA182I5aObject_t   pObj    /* I: Driver object */
    )
{
    tmErrorCode_t   err = TM_OK;

    /* default typical VCO limits T amb 60  */
    pObj->VCO[2].fmin = TDA182I5a_VCO_LOW_MIN;
    pObj->VCO[2].fmax = TDA182I5a_VCO_LOW_MAX;
    pObj->VCO[1].fmin = TDA182I5a_VCO_MED_MIN;
    pObj->VCO[1].fmax = TDA182I5a_VCO_MED_MAX;
    pObj->VCO[0].fmin = TDA182I5a_VCO_HIGH_MIN;
    pObj->VCO[0].fmax = TDA182I5a_VCO_HIGH_MAX;

    /* Settings for Fvco measurements */

    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Charge_pump_byte__cp_cursel, 0x07, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Sigma_delta_byte_1__LO_Int, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }


    /***** VCO High fmax measurement **********/
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Charge_pump_byte__ICP_Force_Src, 0x01, Bus_None );
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Charge_pump_byte__ICP_Force_Sink, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_LoChain_byte__PLL_Div2_Highfreq, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.",  pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Sigma_prog_byte__Update_prg, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
        err = err | iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Sigma_prog_byte__Update_prg, 0x00, Bus_None);
    }

    if(err == TM_OK)
    {
        err = iTDA182I5a_ReadFVCO(pObj, 0, 0);  /* VCO high , Freq max */
    }

    /***** VCO Mid fmax measurement **********/
    if(err == TM_OK)
    {
        err = iTDA182I5a_ReadFVCO(pObj, 1, 0);  /* VCO Med , Freq max */
    }

    /***** VCO High fmin measurement **********/
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Charge_pump_byte__ICP_Force_Src, 0x00, Bus_None );
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Charge_pump_byte__ICP_Force_Sink, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.",  pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_LoChain_byte__PLL_Div2_Highfreq, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.",  pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Sigma_prog_byte__Update_prg, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
        err = err | iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Sigma_prog_byte__Update_prg, 0x00, Bus_None);
    }

    if(err == TM_OK)
    {
        err = iTDA182I5a_ReadFVCO(pObj, 0, 1);  /* VCO high , Freq min */
    }

    /***** VCO Mid fmin measurement **********/
    if(err == TM_OK)
    {
        err = iTDA182I5a_ReadFVCO(pObj, 1, 1);  /* VCO Med , Freq min */
    }
    
    /***** VCO Low fmin measurement **********/
    if(err == TM_OK)
    {
        err = iTDA182I5a_ReadFVCO(pObj, 2, 1);  /* VCO low , Freq min */
    }

    /***** VCO Low fmax measurement **********/
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Charge_pump_byte__ICP_Force_Src, 0x01, Bus_None );
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Charge_pump_byte__ICP_Force_Sink, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.",  pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_ReadFVCO(pObj, 2, 0);  /* VCO low , Freq max */
    }

    /* restore ICP params */
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Charge_pump_byte__ICP_Force_Src, 0x00, Bus_None );
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Charge_pump_byte__ICP_Force_Sink, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.",  pObj->tUnitW));
    }

    if(err == TM_OK)
    {
        err = iTDA182I5a_ReadThermo(pObj, &pObj->Temp_Meas);
    }
    return err;
}
/*============================================================================*/
/* FUNCTION:    iTDA182I5a_ReadFVCO   :     i : VCO number, i: 0 max 1 min     */
/*                                                                            */
/* DESCRIPTION: launch VCO measure and store                                  */
/*             store in pObj->VCO[i].fmax & fmin                              */
/*                                                                            */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
static tmErrorCode_t
iTDA182I5a_ReadFVCO(
    pTDA182I5aObject_t   pObj,    /* I: Driver object */
    UInt8            VCOnum,  /* I: VCO index */
    UInt8            VCOfreq   /* 0: max  1: min */ 
    )
{
    tmErrorCode_t   err = TM_OK;
    UInt8 uVal=0;
    UInt32 FreqVal = 0, FreqRef = 0, FreqRatio = 0;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_ReadFVCO(0x%08X)", pObj->tUnitW);
    
    if(err == TM_OK)
    {
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_VCO_byte__VCO_Select, &uVal, Bus_None);
        if (uVal != VCOnum) err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_VCO_byte__VCO_Select, VCOnum, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }

    /* Set state machine and Launch it */
    err = iTDA182I5a_MSMLaunch(pObj, TDA182I5a_MSM_VCO_Freq_Meas);
    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_MSMLaunch(0x%08X, TDA182I5a_MSM_VCO_Freq) failed.", pObj->tUnitW));

    if(err == TM_OK)
    {
        /* State reached after 10 ms max */
        err = iTDA182I5a_WaitIRQ(pObj, 10, 1);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_WaitIRQ(0x%08X) failed.",  pObj->tUnitW));
    }
    /* read & store measured freq */
    if(err == TM_OK)
    {
        err = iTDA182I5a_ReadRegMap(pObj, gTDA182I5a_Reg_FVCO_MAX_BYTE_1__FVCO_max_1.Address, 0x03);
    }
    if(err == TM_OK)
    {
        /* Value read  over 24 bits equal to frequence in Khz divided by 4 */
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_FVCO_MAX_BYTE_1__FVCO_max_1, &uVal, Bus_None);
        FreqVal = uVal << 16;
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_FVCO_MAX_BYTE_2__FVCO_max_2, &uVal, Bus_None);
        FreqVal = FreqVal + (uVal <<8);
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_FVCO_MAX_BYTE_3__FVCO_max_3, &uVal, Bus_None);
        FreqVal = (FreqVal + uVal) * 4;  /* convert from Khz/4 to Khz */
        FreqRef = (VCOfreq==0)? pObj->VCO[VCOnum].fmax : pObj->VCO[VCOnum].fmin;
        /* check read Value not over 20%  typical VCO limits */
        FreqRatio = (FreqVal>FreqRef)? FreqVal*10 / FreqRef : FreqRef*10 /FreqVal  ;
        if (VCOfreq==0 && FreqRatio < 12)
        {
            pObj->VCO[VCOnum].fmax  = FreqVal;
        }
        else if (FreqRatio < 12)
        {
            pObj->VCO[VCOnum].fmin  = FreqVal;
        }
    }    

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_ReadFVCO(0x%08X)", pObj->tUnitW);
    return err;
}


/*============================================================================*/
/* FUNCTION:    iTDA182I5a_VCOselection:                                       */
/*                                                                            */
/* DESCRIPTION: Choose VCO fct ( Termo + LO ( RF + IF )                       */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
static tmErrorCode_t
iTDA182I5a_VCOselection(
    pTDA182I5aObject_t   pObj    /* I: Driver object */
    )
{
    tmErrorCode_t   err = TM_OK;
    UInt8 NLOi=0, NLOsup=0, VCOnum=0,VCOsup=0, VCOinf=0, VCOi=0;
    Int8 NLOinf=0;
    Int32 VCOsupmarginup=0, VCOinfmarginup=0, VCOsupmargindown=0,VCOinfmargindown=0,FCVO_marge_MFT_inf=0, FCVO_marge_MFT_sup=0;
    UInt32 LO=0, FCVOsup=0, FCVOinf=0; /* calcl in Khz */
    UInt8 NLOtab[9] = { 8, 12, 16, 24, 32, 48, 64, 96, 128 };
    UInt32 diffupfreq[3]={0, 0, 0}, diffdofreq[3]={0, 0, 0} ;
    UInt32 FreqWIFI5G = 5855000;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_VCOselection(0x%08X)", pObj->tUnitW);


    LO = pObj->uLO / 1000;  /* in Khz */
    tmDBGPRINTEx(DEBUGLVL_TERSE, ";LO ; NLOinf; FVCOinf;  VCOinf ;Mup ; Mdo ;  NLOsup; FCVOsup;  VCOsup; Mup  ; Mdo ;->; FCVO;  VCO;   NLO; MarUp ; MargDo " );

    /* search  NLO sup */
    NLOsup = 9;
    do 
    {
       NLOsup = NLOsup - 1;
    } while ( (UInt32)(NLOtab[NLOsup]*LO) > (UInt32)(pObj->VCO[0].fmax ) &&  NLOsup > 0 );

    /* search  NLO inf */
    NLOinf = -1;
    do 
    {
       NLOinf = NLOinf + 1;
    } while ( (UInt32)(NLOtab[NLOinf]*LO) < FreqWIFI5G && NLOinf < 8 );

    /* calculate potential drift in T up and down */
    for (VCOi=0; VCOi<3; VCOi++)
    {
        diffupfreq[VCOi] = pObj->VCO[VCOi].fmax / 6622 * 3  * pObj->Temp_Meas; /* T decrease to 0 */
        diffdofreq[VCOi] = pObj->VCO[VCOi].fmax / 6622 * 3  * (125 - pObj->Temp_Meas); /* T increase to 125 */
    }

    /* selection VCO of NLOsup  */
    FCVOsup = NLOtab[NLOsup]*LO;
    FCVO_marge_MFT_sup = (100000+NLOtab[NLOsup]*2000);
    if (FCVOsup > pObj->VCO[TDA182I5a_VCO_Select_VCO_Medium].fmax)
    {
        VCOsup = TDA182I5a_VCO_Select_VCO_High;
        VCOsupmarginup = pObj->VCO[TDA182I5a_VCO_Select_VCO_High].fmax - diffdofreq[TDA182I5a_VCO_Select_VCO_High] - FCVOsup;
        VCOsupmargindown = FCVOsup - pObj->VCO[TDA182I5a_VCO_Select_VCO_High].fmin - diffupfreq[TDA182I5a_VCO_Select_VCO_High];
    }
    else if (FCVOsup > pObj->VCO[TDA182I5a_VCO_Select_VCO_High].fmin)
    { /* H & M decision */
        VCOsupmarginup = pObj->VCO[TDA182I5a_VCO_Select_VCO_Medium].fmax - diffdofreq[TDA182I5a_VCO_Select_VCO_Medium] - FCVOsup;
        VCOsupmargindown = FCVOsup - pObj->VCO[TDA182I5a_VCO_Select_VCO_High].fmin - diffupfreq[TDA182I5a_VCO_Select_VCO_High];
        if ((VCOsupmarginup>FCVO_marge_MFT_sup) || ( VCOsupmargindown < FCVO_marge_MFT_sup))
        {
           VCOsup = TDA182I5a_VCO_Select_VCO_Medium;
           VCOsupmargindown = FCVOsup - pObj->VCO[TDA182I5a_VCO_Select_VCO_Medium].fmin - diffupfreq[TDA182I5a_VCO_Select_VCO_Medium];
        }
        else
        {
           VCOsup = TDA182I5a_VCO_Select_VCO_High;
           VCOsupmarginup = pObj->VCO[TDA182I5a_VCO_Select_VCO_High].fmax - diffdofreq[TDA182I5a_VCO_Select_VCO_High] - FCVOsup;
        }
    }
    else if (FCVOsup > pObj->VCO[TDA182I5a_VCO_Select_VCO_Low].fmax)
    {
        VCOsup = TDA182I5a_VCO_Select_VCO_Medium;
        VCOsupmarginup = pObj->VCO[TDA182I5a_VCO_Select_VCO_Medium].fmax - diffdofreq[TDA182I5a_VCO_Select_VCO_Medium] - FCVOsup;
        VCOsupmargindown = FCVOsup - pObj->VCO[TDA182I5a_VCO_Select_VCO_Medium].fmin - diffupfreq[TDA182I5a_VCO_Select_VCO_Medium];
    }
    else if (FCVOsup > pObj->VCO[TDA182I5a_VCO_Select_VCO_Medium].fmin)
    { /* M & L decision */
        VCOsupmarginup = pObj->VCO[TDA182I5a_VCO_Select_VCO_Low].fmax - diffdofreq[TDA182I5a_VCO_Select_VCO_Low] - FCVOsup;
        VCOsupmargindown = FCVOsup - pObj->VCO[TDA182I5a_VCO_Select_VCO_Medium].fmin - diffupfreq[TDA182I5a_VCO_Select_VCO_Medium];
        if ((VCOsupmarginup>FCVO_marge_MFT_sup) || ( VCOsupmargindown < FCVO_marge_MFT_sup))
        {
            VCOsup = TDA182I5a_VCO_Select_VCO_Low;
            VCOsupmargindown = pObj->VCO[TDA182I5a_VCO_Select_VCO_Low].fmin + diffupfreq[TDA182I5a_VCO_Select_VCO_Low]; 
            VCOsupmargindown = VCOsupmargindown > (Int32)FreqWIFI5G ? VCOsupmargindown:(Int32)FreqWIFI5G;     
            VCOsupmargindown = FCVOsup - VCOsupmargindown;
        }
        else
        {
           VCOsup = TDA182I5a_VCO_Select_VCO_Medium;
           VCOsupmarginup = pObj->VCO[TDA182I5a_VCO_Select_VCO_Medium].fmax - diffdofreq[TDA182I5a_VCO_Select_VCO_Medium] - FCVOsup;
        }
    }
    else
    {
        VCOsup = TDA182I5a_VCO_Select_VCO_Low;
        VCOsupmarginup = pObj->VCO[TDA182I5a_VCO_Select_VCO_Low].fmax - diffdofreq[TDA182I5a_VCO_Select_VCO_Low] - FCVOsup;
        VCOsupmargindown = pObj->VCO[TDA182I5a_VCO_Select_VCO_Low].fmin + diffupfreq[TDA182I5a_VCO_Select_VCO_Low]; 
        VCOsupmargindown = VCOsupmargindown > (Int32)FreqWIFI5G ? VCOsupmargindown:(Int32)FreqWIFI5G;     
        VCOsupmargindown = FCVOsup - VCOsupmargindown;
    }

    VCOsupmarginup  = VCOsupmarginup - FCVO_marge_MFT_sup;
    VCOsupmargindown = VCOsupmargindown - FCVO_marge_MFT_sup;

    if ( NLOinf == NLOsup)
    {
        VCOnum = VCOsup;
        NLOi = NLOsup;
    }
    else
    {
        /* selection VCO of NLOinf  */
        FCVOinf = NLOtab[NLOinf]*LO;
        FCVO_marge_MFT_inf = (100000+NLOtab[NLOinf]*2000);
        if (FCVOinf > pObj->VCO[TDA182I5a_VCO_Select_VCO_Medium].fmax)
        {
            VCOinf = TDA182I5a_VCO_Select_VCO_High;
            VCOinfmarginup = pObj->VCO[TDA182I5a_VCO_Select_VCO_High].fmax - diffdofreq[TDA182I5a_VCO_Select_VCO_High] - FCVOinf;
            VCOinfmargindown = FCVOinf - pObj->VCO[TDA182I5a_VCO_Select_VCO_High].fmin - diffupfreq[TDA182I5a_VCO_Select_VCO_High];
        }
        else if (FCVOinf > pObj->VCO[TDA182I5a_VCO_Select_VCO_High].fmin)
        { /* H & M decision */
            VCOinfmarginup = pObj->VCO[TDA182I5a_VCO_Select_VCO_Medium].fmax - diffdofreq[TDA182I5a_VCO_Select_VCO_Medium] - FCVOinf;
            VCOinfmargindown = FCVOinf - pObj->VCO[TDA182I5a_VCO_Select_VCO_High].fmin - diffupfreq[TDA182I5a_VCO_Select_VCO_High];
            if ((VCOinfmarginup>FCVO_marge_MFT_inf) || ( VCOinfmargindown < FCVO_marge_MFT_inf))
            {
               VCOinf = TDA182I5a_VCO_Select_VCO_Medium;
               VCOinfmargindown = FCVOinf - pObj->VCO[TDA182I5a_VCO_Select_VCO_Medium].fmin - diffupfreq[TDA182I5a_VCO_Select_VCO_Medium];
            }
            else
            {
               VCOinf = TDA182I5a_VCO_Select_VCO_High;
               VCOinfmarginup = pObj->VCO[TDA182I5a_VCO_Select_VCO_High].fmax - diffdofreq[TDA182I5a_VCO_Select_VCO_High] - FCVOinf;
            }
        }
        else if (FCVOinf > pObj->VCO[TDA182I5a_VCO_Select_VCO_Low].fmax)
        {
            VCOinf = TDA182I5a_VCO_Select_VCO_Medium;
            VCOinfmarginup = pObj->VCO[TDA182I5a_VCO_Select_VCO_Medium].fmax - diffdofreq[TDA182I5a_VCO_Select_VCO_Medium] - FCVOinf;
            VCOinfmargindown = FCVOinf - pObj->VCO[TDA182I5a_VCO_Select_VCO_Medium].fmin - diffupfreq[TDA182I5a_VCO_Select_VCO_Medium];
        }
        else if (FCVOinf > pObj->VCO[TDA182I5a_VCO_Select_VCO_Medium].fmin)
        { /* M & L decision */
            VCOinfmarginup = pObj->VCO[TDA182I5a_VCO_Select_VCO_Low].fmax - diffdofreq[TDA182I5a_VCO_Select_VCO_Low] - FCVOinf;
            VCOinfmargindown = FCVOinf - pObj->VCO[TDA182I5a_VCO_Select_VCO_Medium].fmin - diffupfreq[TDA182I5a_VCO_Select_VCO_Medium];
            if ((VCOinfmarginup>FCVO_marge_MFT_inf) || ( VCOinfmargindown < FCVO_marge_MFT_inf))
            {
                VCOinf = TDA182I5a_VCO_Select_VCO_Low;
                VCOinfmargindown = pObj->VCO[TDA182I5a_VCO_Select_VCO_Low].fmin + diffupfreq[TDA182I5a_VCO_Select_VCO_Low]; 
                VCOinfmargindown = VCOinfmargindown > (Int32)FreqWIFI5G ? VCOinfmargindown:(Int32)FreqWIFI5G;     
                VCOinfmargindown = FCVOinf - VCOinfmargindown;
            }
            else
            {
               VCOinf = TDA182I5a_VCO_Select_VCO_Medium;
               VCOinfmarginup = pObj->VCO[TDA182I5a_VCO_Select_VCO_Medium].fmax - diffdofreq[TDA182I5a_VCO_Select_VCO_Medium] - FCVOinf;
            }
        }
        else
        {
            VCOinf = TDA182I5a_VCO_Select_VCO_Low;
            VCOinfmarginup = pObj->VCO[TDA182I5a_VCO_Select_VCO_Low].fmax - diffdofreq[TDA182I5a_VCO_Select_VCO_Low] - FCVOinf;
            VCOinfmargindown = pObj->VCO[TDA182I5a_VCO_Select_VCO_Low].fmin + diffupfreq[TDA182I5a_VCO_Select_VCO_Low]; 
            VCOinfmargindown = VCOinfmargindown > (Int32)FreqWIFI5G ? VCOinfmargindown:(Int32)FreqWIFI5G;     
            VCOinfmargindown = FCVOinf - VCOinfmargindown;
        }

        VCOinfmarginup = VCOinfmarginup - FCVO_marge_MFT_inf;
        VCOinfmargindown = VCOinfmargindown - FCVO_marge_MFT_inf;

         /* choose best VCO either FCVOinf or FCVOsup */
         if((VCOsupmarginup>0) && (VCOsupmargindown>0) && (VCOinfmarginup>0) && (VCOinfmargindown>0))
         {
             if (VCOsupmarginup < VCOinfmarginup )
             {
                 VCOnum = VCOsup;
                 NLOi = NLOsup;
             }
             else 
             {
                 VCOnum = VCOinf;
                 NLOi = NLOinf;
             }
         }
         else if((VCOsupmarginup>0) && (VCOsupmargindown>0))
         {
             VCOnum = VCOsup;
             NLOi = NLOsup;
         }
         else if((VCOinfmarginup>0) && (VCOinfmargindown>0))
         {
             VCOnum = VCOinf;
             NLOi = NLOinf;
         }
         else
         {

             /* eliminate VCO choice with lowest margin either up or down */
             if (VCOinfmargindown < VCOinfmarginup)
             {
                if(VCOinfmargindown < VCOsupmargindown)
                {
                    if(VCOinfmargindown < VCOsupmarginup)
                    {
                        VCOnum = VCOsup;
                        NLOi = NLOsup;
                    }
                    else
                    {
                        VCOnum = VCOinf;
                        NLOi = NLOinf;
                    }
                }
                else
                {
                    VCOnum = VCOinf;
                    NLOi = NLOinf;
                }
             }
             else
             {
                if(VCOinfmarginup < VCOsupmargindown)
                {
                    if(VCOinfmarginup < VCOsupmarginup)
                    {
                        VCOnum = VCOsup;
                        NLOi = NLOsup;
                    }
                    else
                    {
                        VCOnum = VCOinf;
                        NLOi = NLOinf;
                    }
                }
                else
                {
                    VCOnum = VCOinf;
                    NLOi = NLOinf;
                }
             }
         }
     }

    pObj->uFVCO = NLOtab[NLOi]*LO ;

    /* Write VCO selection */
    err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_VCO_byte__VCO_Select, VCOnum, Bus_NoRead);
    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));


    tmDBGPRINTEx(DEBUGLVL_TERSE, ";%d;  %d ; %d; %d  ;%d ;%d;  %d ; %d;  %d  ;%d ; %d ; -> ; %d;  %d; %d ; %d ; %d", \
        LO, (NLOinf==NLOsup ? 0 : NLOtab[NLOinf]), (NLOinf==NLOsup ? 0 : (NLOtab[NLOinf]*LO)), (NLOinf==NLOsup ? 0 : VCOinf), (NLOinf==NLOsup ? 0 :VCOinfmarginup), (NLOinf==NLOsup ? 0 :VCOinfmargindown), \
        NLOtab[NLOsup], (NLOtab[NLOsup]*LO), VCOsup, VCOsupmarginup, VCOsupmargindown, \
        pObj->uFVCO, VCOnum,  NLOtab[NLOi], ( (NLOi==NLOsup) ? VCOsupmarginup : VCOinfmarginup ), ( (NLOi==NLOsup) ? VCOsupmargindown : VCOinfmargindown ));

    if (err == TM_OK)
    {
        /* Write LoChain_ratio with decoding as below  */
        /*  NLOtab = { 8, 12, 16, 24, 32, 48, 64, 96, 128 };
      LO chain ration  2  3   4   6    8  12  16  24  32
          value I2C     0  1   2   3    8   9  10  11  12  */

        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_LoChain_byte__LoChain_ratio, (NLOi<4?NLOi:NLOi+4), Bus_None);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));

        /* adapt PLL_Div2_Highfreq vs FVCO 8Ghz limit*/
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_LoChain_byte__PLL_Div2_Highfreq, (pObj->uFVCO > 8000000 ? 0x01 : 0x00), Bus_NoRead);
    }

    return err;

}

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_SetRF:                                              */
/*                                                                            */
/* DESCRIPTION: Tunes to a RF.                                                */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_SetRF(
    pTDA182I5aObject_t   pObj    /* I: Driver object */
)
{
    tmErrorCode_t   err = TM_OK;

#ifdef DIVERSITY_SETRF_NOFAST
    err = iTDA182I5a_Diversity_SetRF_NoFast(pObj);
#else
    err = iTDA182I5a_SetRF_NoFast(pObj);
#endif

    /* force Gains to max  */
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_RF_byte__AGCs_loop_off, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC2_byte_2__AGC2_Gain, 141, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
         err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_RF_byte__Force_AGC2_gain, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IR_Mixer_byte_2__Force_AGC4_gain, 0x01, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IR_Mixer_byte_2__AGC4_Gain, 4, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC5_byte_2__Force_AGC5_gain, 0x01, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC5_byte_2__AGC5_Gain, 7, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    /* release Gains  */
    if(err == TM_OK)
    {
         err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_RF_byte__Force_AGC2_gain, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IR_Mixer_byte_2__Force_AGC4_gain, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC5_byte_2__Force_AGC5_gain, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_RF_byte__AGCs_loop_off, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }

    /* Launch AGC fast mode */
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_MSM_byte_2__AGC_CC_Fast_Launch, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_MSM_byte_2__AGC_CC_Fast_Launch, 0x00, Bus_None);
    }
    
    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_SetRF:                                              */
/*                                                                            */
/* DESCRIPTION: Tunes to a RF.                                                */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_SetRF_NoFast(
    pTDA182I5aObject_t   pObj    /* I: Driver object */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt8 uVal=0;

    /* program spectral inversion mode */
    err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IR_Mixer_byte_1__hrm_swap, pObj->SpectralInversion, Bus_NoRead);
    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));


    if(err == TM_OK)
    {
        err = iTDA182I5a_SetLO(pObj);
    }

    /*  RF filter programmation: RF_LPF & RF-LPF_Feed & IR_FreqPtr */
    if(err == TM_OK)
    {
        err = iTDA182I5a_SetRF_Freq(pObj);
    }
    /* adapt AGC2 if algo activated */
    if (pObj->pStandard->HighPass_AGC2_algo == TDA182I5a_HighPass_AGC2_Digital)
    {
        if (pObj->uRF >= 766000000)
        {
            uVal = TDA182I5a_AGC2_Highpass_766_MHz;
        }
        else if (pObj->uRF >= 600000000)
        {
            uVal = TDA182I5a_AGC2_Highpass_600_MHz;
        }
        else if (pObj->uRF >= 470000000)
        {
            uVal = TDA182I5a_AGC2_Highpass_470_MHz;
        }
        else if (pObj->uRF >= 180000000)
        {
            uVal = TDA182I5a_AGC2_Highpass_180_MHz;
        }
        else
        {
            uVal = TDA182I5a_AGC2_Highpass_20_MHz;
        }
    }
    else if (pObj->pStandard->HighPass_AGC2_algo == TDA182I5a_HighPass_AGC2_Analog_GH)
    {
        if (pObj->uRF >= 580000000)
        {
            uVal = TDA182I5a_AGC2_Highpass_20_MHz;
        }
        else if (pObj->uRF >= 470000000)
        {
            uVal = TDA182I5a_AGC2_Highpass_470_MHz;
        }
        else if (pObj->uRF >= 180000000)
        {
            uVal = TDA182I5a_AGC2_Highpass_180_MHz;
        }
        else
        {
            uVal = TDA182I5a_AGC2_Highpass_20_MHz;
        }
    }
    else if (pObj->pStandard->HighPass_AGC2_algo == TDA182I5a_HighPass_AGC2_Analog)
    {
        if (pObj->uRF >= 700000000)
        {
            uVal = TDA182I5a_AGC2_Highpass_600_MHz;
        }
        else if (pObj->uRF >= 580000000)
        {
            uVal = TDA182I5a_AGC2_Highpass_20_MHz;
        }
        else if (pObj->uRF >= 470000000)
        {
            uVal = TDA182I5a_AGC2_Highpass_470_MHz;
        }
        else if (pObj->uRF >= 180000000)
        {
            uVal = TDA182I5a_AGC2_Highpass_180_MHz;
        }
        else
        {
            uVal = TDA182I5a_AGC2_Highpass_20_MHz;
        }
    }
    else if (pObj->pStandard->HighPass_AGC2_algo == TDA182I5a_HighPass_AGC2_QAM6)
    {
        if (pObj->uRF > 610000000)
        {
            uVal = TDA182I5a_AGC2_Highpass_600_MHz;
        }
        else if (pObj->uRF > 500000000)
        {
            uVal = TDA182I5a_AGC2_Highpass_470_MHz;
        }
        else if (pObj->uRF > 200000000)
        {
            uVal = TDA182I5a_AGC2_Highpass_180_MHz;
        }
        else
        {
            uVal = TDA182I5a_AGC2_Highpass_20_MHz;
        }
    }
    else if (pObj->pStandard->HighPass_AGC2_algo == TDA182I5a_HighPass_AGC2_QAM8)
    {
        if (pObj->uRF > 750000000)
        {
            uVal = TDA182I5a_AGC2_Highpass_766_MHz;
        }
        else if (pObj->uRF > 300000000)
        {
            uVal = TDA182I5a_AGC2_Highpass_600_MHz;
        }
        else if (pObj->uRF > 200000000)
        {
            uVal = TDA182I5a_AGC2_Highpass_180_MHz;
        }
        else
        {
            uVal = TDA182I5a_AGC2_Highpass_20_MHz;
        }
    }
    else if (pObj->pStandard->HighPass_AGC2_algo == TDA182I5a_HighPass_AGC2_20MHZ)
    {
        uVal = TDA182I5a_AGC2_Highpass_20_MHz;
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_RF_Filters_byte_1__AGC2_Highpass, uVal, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }

    
    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_SetLO:                                              */
/*                                                                            */
/* DESCRIPTION: Tunes to a LO.                                                */
/*                                                                            */
/* RETURN:      TM_OK                                                         */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_SetLO(
    pTDA182I5aObject_t   pObj    /* I: Driver object */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt8 counter=0, uVal=0, uThermo=0, VCOnum=0, VCOnum_new=0;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_SetRF(0x%08X)", pObj->tUnitW);


    if(pObj->curPowerState != tmPowerOn)
    {
        /* Set power state ON */
        err = iTDA182I5a_SetLLPowerState(pObj, TDA182I5a_PowerNormalMode);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_SetLLPowerState(0x%08X, PowerNormalMode) failed.", pObj->tUnitW));
    }

    /* Set Dig_Clock to 16MHz here */
    if(err == TM_OK)
    {
        pObj->curPowerState = tmPowerOn;
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Reference_Byte__Dig_Clock, TDA182I5a_Dig_Clock_16MHz, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
       /* Set cp_cursel */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Charge_pump_byte__cp_cursel, TDA182I5a_cp_cursel_420_uA , Bus_None);
       /* Set cp_cursel */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Charge_pump_byte__cpleak0, 0x00 , Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
       /* Set VCO_currentctrl */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_VCO_cal_byte_1__VCO_currentctrl, 0x00 , Bus_None);
       /* Set VCOampl_force_cur */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_VCO_cal_byte_1__VCOampl_force_cur, 0x01 , Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }

    /* Read Thermo */
    if(err == TM_OK)
    {
        err = iTDA182I5a_ReadThermo( pObj, &uThermo );
    }

    /* VCO selection */
    if(err == TM_OK)
    {
        err = iTDA182I5a_VCOselection(pObj);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_VCOselection(0x%08X) failed.", pObj->tUnitW));
    }

    if(err == TM_OK)
    {
        err = iTDA182I5a_SetPLL(pObj);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_SetPLL(0x%08X) failed.", pObj->tUnitW));
    }

    /* Wait LO_Lock timeout 20ms */
    counter = 20;
    while(counter > 0)
    {
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_Power_state_byte_1__LO_Lock, &uVal, Bus_NoWrite);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Read(0x%08X) failed.", pObj->tUnitW));
        if(err==TM_OK && uVal==0x01)
        {
            /* PLL Lock */
            break;
        }
        if(counter)
        {
            /* Decrease the counter */
            counter--;

            /* Wait for a step of  1ms */
            err = iTDA182I5a_Wait(pObj, 1);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Wait(0x%08X) failed.", pObj->tUnitW));
        }
	}
    if (err==TM_OK && counter==0)
    {  /* timeout LO_lock reached */
        err = TDA182I5a_ERR_NOT_READY; 

        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_SetLO(0x%08X) 1st timeout LO_lock reached.", pObj->tUnitW));
    }

    /* Vtune sense and VCO adaptation */
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Power_Down_byte_1__PD_adc_vtune, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_vco_log__adc_vtune, &uVal, Bus_NoWrite);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Power_Down_byte_1__PD_adc_vtune, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    /* adapt VCO swing Ctrl vs adc_vtune */
    if(err == TM_OK)
    {
        err = iTDA182I5a_Adapt_vco_swingctrl(pObj, uVal, VCOnum_new);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_VCO_cal_byte_1__VCOampl_force_cur, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    /* run VCP amp */
    if(err == TM_OK)
    {
        err = iTDA182I5a_MSMLaunch(pObj, TDA182I5a_MSM_VCO_Ampl_Cal);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_SetMSM(0x%08X, TDA182I5a_MSM_HwInit) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        /* State reached after 10ms max */
        err = iTDA182I5a_WaitIRQ(pObj, 10, 1);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_WaitIRQ(0x%08X) failed.", pObj->tUnitW));
    }
    /* Vtune sense and VCO adaptation */
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Power_Down_byte_1__PD_adc_vtune, 0x00, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_vco_log__adc_vtune, &uVal, Bus_NoWrite);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Power_Down_byte_1__PD_adc_vtune, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_VCO_byte__VCO_Select, &VCOnum, Bus_None);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Read(0x%08X) failed.", pObj->tUnitW));
    }

    /* check potential VCO change */
    VCOnum_new = VCOnum;
    if ((err == TM_OK) && (uVal > 5) && (uThermo < 50) && VCOnum!=TDA182I5a_VCO_Select_VCO_High) /* vt > 1.8v & tj < 50 */
    {
        /* Choose upper VCO  */
        tmDBGPRINTEx(DEBUGLVL_TERSE,"request upper  VCO  change  %d\n\r");
        /* check VCO capabilities */
        if ( (pObj->VCO[VCOnum-1].fmin <= pObj->uFVCO ) && ( pObj->uFVCO <= pObj->VCO[VCOnum-1].fmax ) )
        {
            VCOnum_new = VCOnum-1;
            tmDBGPRINTEx(DEBUGLVL_TERSE,"Change VCO  sup %d\n\r", VCOnum_new);
        }    
    }
    else if ((err == TM_OK) && (uVal < 3 ) && (uThermo > 90 ) && VCOnum!=TDA182I5a_VCO_Select_VCO_Low) /* vt < 0.3v & tj > 90 */
    {
        /* Choose lower VCO  */
        tmDBGPRINTEx(DEBUGLVL_TERSE,"request lower  VCO  change  %d\n\r");
       /* check VCO capabilities */
        if ( (pObj->VCO[VCOnum+1].fmin <= pObj->uFVCO ) && ( pObj->uFVCO <= pObj->VCO[VCOnum+1].fmax ) )
        {
            VCOnum_new = VCOnum+1;
            tmDBGPRINTEx(DEBUGLVL_TERSE,"Change VCO  inf %d\n\r", VCOnum_new);
        }
    }
    if ((err == TM_OK) && (VCOnum_new != VCOnum))
    {    /* VCO change needed */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_VCO_byte__VCO_Select, VCOnum_new, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));

        /* Wait LO_Lock timeout 20ms */
        counter = 20;
        while(counter > 0)
        {
            err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_Power_state_byte_1__LO_Lock, &uVal, Bus_NoWrite);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Read(0x%08X) failed.", pObj->tUnitW));
            if(err==TM_OK && uVal==0x01)
            {
                /* PLL Lock */
                break;
            }
            if(counter)
            {
                /* Decrease the counter */
                counter--;

                /* Wait for a step of  1ms */
                err = iTDA182I5a_Wait(pObj, 1);
                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Wait(0x%08X) failed.", pObj->tUnitW));
            }
	    }
        if (err==TM_OK && counter==0)
        {  /* timeout LO_lock reached */
            err = TDA182I5a_ERR_NOT_READY; 

            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_SetLO(0x%08X) 2nd timeout LO_lock reached.", pObj->tUnitW));
        }
        /* re Vtune sense */
        if(err == TM_OK)
        {
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Power_Down_byte_1__PD_adc_vtune, 0x00, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
        }
        if(err == TM_OK)
        {
            err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_vco_log__adc_vtune, &uVal, Bus_NoWrite);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
        }
        if(err == TM_OK)
        {
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Power_Down_byte_1__PD_adc_vtune, 0x01, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
        }
    }
    /* Check temp & constraints on selected VCO to force or run normal VCO_Ampl_Cal */
    if((err == TM_OK) &&(uThermo > 75))
    {
         err = iTDA182I5a_Force_vco_currentctrl(pObj, uVal, VCOnum_new);
    }
    else
    {
        /* prepare VCO amp cal */
        /* adapt VCO swing Ctrl vs adc_vtune */
        if(err == TM_OK)
        {
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Power_Down_byte_1__PD_adc_vtune, 0x00, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
        }
        if(err == TM_OK)
        {
            err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_vco_log__adc_vtune, &uVal, Bus_NoWrite);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
        }
        if(err == TM_OK)
        {
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Power_Down_byte_1__PD_adc_vtune, 0x01, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
        }
        if(err == TM_OK)
        {
            err = iTDA182I5a_Adapt_vco_swingctrl(pObj, uVal, VCOnum_new);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
        }
        if(err == TM_OK)
        {
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_VCO_cal_byte_1__VCOampl_force_cur, 0x00, Bus_NoRead);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
        }
        /* run VCP amp */
        if(err == TM_OK)
        {
            err = iTDA182I5a_MSMLaunch(pObj, TDA182I5a_MSM_VCO_Ampl_Cal);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_SetMSM(0x%08X, TDA182I5a_MSM_HwInit) failed.", pObj->tUnitW));
        }
        if(err == TM_OK)
        {
            /* State reached after 10ms max */
            err = iTDA182I5a_WaitIRQ(pObj, 10, 1);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_WaitIRQ(0x%08X) failed.", pObj->tUnitW));
        }
    }
    /* Adapt CP vs adc_vtune / VCO select */
    if(err == TM_OK)
    {
        err = iTDA182I5a_AdaptICP(pObj, uVal, VCOnum_new);
    }
    
    /* TDA18275A: don't set Dig_Clock to SubLO anymore */
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Reference_Byte__Dig_Clock, TDA182I5a_Dig_Clock_SubLO, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    
    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_ProgramLPF                                          */
/*                                                                            */
/* DESCRIPTION: Sets Tuner Frequency registers.                               */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_ProgramLPF(
    pTDA182I5aObject_t   pObj,   /* I: Driver object */
    UInt32 uIndex               /* I: index in the LU table */
)
{
    tmErrorCode_t err = TM_OK;
    UInt16 RF_LPF, RF_LPF_Feed ;

    RF_LPF = Code_Lu[uIndex].gnd ;
    RF_LPF_Feed = Code_Lu[uIndex].feed ;

    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_RF_Low_Pass_Filter_byte_1__RF_LPF_1, (UInt8)((RF_LPF&0x0FF0)>>4), Bus_None);  /* HI 8 RF_LPF */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_RF_Low_Pass_Filter_byte_2__RF_LPF_2, (UInt8)(RF_LPF&0x000F), Bus_None);  /* LO 4 RF_LPF */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_RF_Low_Pass_Filter_byte_3__RF_LPF_f_2, (UInt8)(RF_LPF_Feed&0x00FF), Bus_None); /*LO 8 RF_LPF_f */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_RF_Low_Pass_Filter_byte_2__RF_LPF_f_1, (UInt8)((RF_LPF_Feed&0x0F00)>>8), Bus_None); /* HI 4 RF_LPF_f */
    }

    if(err == TM_OK)
    {
        /* Write bytes RF_Low_Pass_Filter_byte_1 to RF_Low_Pass_Filter_byte_3 */
        err = iTDA182I5a_WriteRegMap(pObj, gTDA182I5a_Reg_RF_Low_Pass_Filter_byte_1.Address, TDA182I5a_REG_DATA_LEN(gTDA182I5a_Reg_RF_Low_Pass_Filter_byte_1, gTDA182I5a_Reg_RF_Low_Pass_Filter_byte_3));
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_WriteRegMap(0x%08X) failed.", pObj->tUnitW));
    }

    if( err == TM_OK)
    {
        /* store programmed value */
        pObj->uLUCodeProgrammed = uIndex;
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_SetRF_Dependencies                                  */
/*                                                                            */
/* DESCRIPTION: Sets settings RF dependant                                    */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_SetRF_Dependencies(
    pTDA182I5aObject_t   pObj   /* I: Driver object */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt8 uVal = 0;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_SetRF_Dependencies(0x%08X)", pObj->tUnitW);

        /* Set AGC1 TOP I2C DN/UP */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top, pObj->pStandard->AGC1_TOP_I2C_DN_UP, Bus_NoRead);

        /* Set  AGC2 TOP I2C DN/UP no write  */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC2_byte_1__AGC2_TOP, pObj->pStandard->AGC2_TOP_I2C_DN_UP, Bus_NoRead);

        /* Set  AGC1 TOP STRATEGY  */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top_Strategy, pObj->pStandard->AGC1_TOP_STRATEGY, Bus_NoRead);

        /* Set  AGC2 TOP STRATEGY  */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC2_byte_1__AGC2_Top_Strategy, pObj->pStandard->AGC2_Top_Strategy, Bus_NoRead);

        /* Set  AGC2 TOP adapt   */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Adapt_Top_byte__Top_adapt_AGC2, pObj->pStandard->AGC2_Adapt_TOP, Bus_NoRead);

    switch (pObj->StandardMode)
    {
        case TDA182I5a_QAM_6MHz:
            if (pObj->uRF > 400000000)
            {
                /* Set AGC1 TOP I2C DN/UP */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top, TDA182I5a_AGC1_Top_102_96_dBuVrms, Bus_NoRead);
                /* Set  AGC2 TOP I2C DN/UP   */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC2_byte_1__AGC2_TOP, TDA182I5a_AGC2_TOP_110_104_103d5_dBuVrms, Bus_NoRead);
                /* Set  AGC2 TOP adapt   */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Adapt_Top_byte__Top_adapt_AGC2, TDA182I5a_Top_adapt_AGC2_No_dynamic_TOP_change, Bus_NoRead);
            }
            else
            {
                /* Set AGC1 TOP I2C DN/UP */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top, TDA182I5a_AGC1_Top_104_98_dBuVrms, Bus_NoRead);
                /* Set  AGC2 TOP I2C DN/UP   */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC2_byte_1__AGC2_TOP, TDA182I5a_AGC2_TOP_114_108_107d5_dBuVrms, Bus_NoRead);
                /* Set  AGC2 TOP adapt   */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Adapt_Top_byte__Top_adapt_AGC2, TDA182I5a_Top_adapt_AGC2_n3_dB_TOP_for_IFLPF_gain_inf_9dB_12dB, Bus_NoRead);
            }             
        break;
        case TDA182I5a_QAM_8MHz:
            if (pObj->uRF > 458000000)
            {
                /* Set  AGC2 TOP I2C DN/UP   */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC2_byte_1__AGC2_TOP, TDA182I5a_AGC2_TOP_110_104_103d5_dBuVrms, Bus_NoRead);
            }
        break;
        case TDA182I5a_ANLG_B:
            if ((pObj->uRF < 700000000) && (pObj->uRF >= 580000000))
            {
                /* Set AGC1 TOP I2C DN/UP */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top, TDA182I5a_AGC1_Top_90_84_dBuVrms, Bus_NoRead);
                /* AGC1 TOP STRATEGY to default */
                /* AGC2 TOP STRATEGY to default */
            }
            else if ((pObj->uRF < 580000000) && (pObj->uRF >= 400000000))
            {
                /* Set AGC1 TOP I2C DN/UP */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top, TDA182I5a_AGC1_Top_100_94_dBuVrms, Bus_NoRead);
                /* AGC1 TOP STRATEGY to default */
                /* AGC2 TOP STRATEGY to default */
            }
            else if (pObj->uRF < 100000000)
            {
                /* AGC1 TOP I2C DN/UP to default*/
                /* Set AGC1 TOP STRATEGY */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top_Strategy, TDA182I5a_AGC1_Top_Strategy_n4_dB_TOP_Do_for_LNA_gain_sup_16_dB, Bus_NoRead);
                /* Set  AGC2 TOP STRATEGY, ! final write Reg_AGC2_byte_1  */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC2_byte_1__AGC2_Top_Strategy, TDA182I5a_AGC2_Top_Strategy_n1dB_n6dB_TOP_Do_for_LNA_gain_sup_10dB_16dB, Bus_NoRead);
            }
        break;
        case TDA182I5a_ANLG_GH:
            if (pObj->uRF >= 700000000)
            {
                /* AGC1 TOP I2C DN/UP to default*/
                /* Set  AGC2 TOP I2C DN/UP   */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC2_byte_1__AGC2_TOP, TDA182I5a_AGC2_TOP_107_101_100d5_dBuVrms, Bus_NoRead);
            }
            else if ((pObj->uRF < 700000000) && (pObj->uRF >= 580000000))
            {
                /* set AGC1 TOP I2C DN/UP */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top, TDA182I5a_AGC1_Top_90_84_dBuVrms, Bus_NoRead);
                /* AGC2 TOP I2C DN/UP to default  */
            }
            else if ((pObj->uRF < 580000000) && (pObj->uRF >= 400000000))
            {
                /* Set AGC1 TOP I2C DN/UP */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top, TDA182I5a_AGC1_Top_100_94_dBuVrms, Bus_NoRead);
                /* AGC2 TOP I2C DN/UP to default  */
            }
        break;
        case TDA182I5a_ANLG_DK:
            if (pObj->uRF >= 700000000)
            {
                /* set AGC1 TOP I2C DN/UP */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top, TDA182I5a_AGC1_Top_98_92_dBuVrms, Bus_NoRead);
            }
            else if ((pObj->uRF < 700000000) && (pObj->uRF >= 580000000))
            {
                /* set AGC1 TOP I2C DN/UP */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top, TDA182I5a_AGC1_Top_90_84_dBuVrms, Bus_NoRead);
            }
        break;
        case TDA182I5a_ANLG_I:
            if ((pObj->uRF < 700000000) && (pObj->uRF >= 580000000))
            {
                /* set AGC1 TOP I2C DN/UP */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top, TDA182I5a_AGC1_Top_90_84_dBuVrms, Bus_NoRead);
            }
            else if ((pObj->uRF < 580000000) && (pObj->uRF >= 400000000))
            {
                /* set AGC1 TOP I2C DN/UP */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top, TDA182I5a_AGC1_Top_100_94_dBuVrms, Bus_NoRead);
            }
        break;
        case TDA182I5a_FM_Radio:
        case TDA182I5a_ANLG_MN:
        case TDA182I5a_ANLG_LL:
            if (pObj->uRF >= 580000000)
            {
                /* set AGC1 TOP I2C DN/UP */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_AGC1_byte_1__AGC1_Top, TDA182I5a_AGC1_Top_90_84_dBuVrms, Bus_NoRead);
            }
        break;
        case TDA182I5a_ANLG_L:
        default:
        break;
    }
    /* LNA High pass restriction : to be desactivated under 250MHz */
    err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_RF_Filters_byte_1__LNA_Highpass, &uVal, Bus_None);
    if (pObj->uRF < 250000000 && uVal==TDA182I5a_LNA_Highpass_Enabled)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_RF_Filters_byte_1__LNA_Highpass, TDA182I5a_LNA_Highpass_Disabled, Bus_NoWrite);
    }

    return err;

}
/*============================================================================*/
/* FUNCTION:    iTDA182I5a_SetRF_Freq                                          */
/*                                                                            */
/* DESCRIPTION: Sets Tuner Frequency registers.                               */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_SetRF_Freq(
    pTDA182I5aObject_t   pObj   /* I: Driver object */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt8 uVal=0;
    UInt8 index = 0;
    UInt32 fmax=0;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_SetRF_Freq(0x%08X)", pObj->tUnitW);

    /* settings standard RF dependant */
    if(err == TM_OK)
    {
#ifdef DIVERSITY_SETRF_DEPENDENCIES
        err = iTDA182I5a_Diversity_SetRF_Dependencies(pObj);
#else
        err = iTDA182I5a_SetRF_Dependencies(pObj);
#endif
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_SetRF_Dependencies(0x%08X) failed.", pObj->tUnitW));
    }

    fmax = (pObj->uRF + pObj->pStandard->Offset_fmax) / 1000; /* in Khz */

    if (pObj->uRF > 333000000 &&  ( pObj->StandardMode==TDA182I5a_QAM_8MHz || pObj->StandardMode==TDA182I5a_QAM_6MHz ))
    {
        err = iTDA182I5a_ProgramLPF( pObj, 0 );
    }
    else
    {
        /* Get RCcal from HWinit */
        if(err == TM_OK)
        {
            err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_RC_Cal_byte_2__RCcal, &uVal, Bus_None);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
        }

        /* Find RF_LPF[11:0] & RF_LPF_feed[11:0] table vs Rccal_read & RFfreq */
        do 
        {
           index = index + 1;
        } while (( TDA182I5a_FilterRF[index-1].LO_upto < fmax ) && ( index < sizeof(TDA182I5a_FilterRF)/sizeof(TDA182I5a_FilterRFDef)));
        err = iTDA182I5a_ProgramLPF( pObj, TDA182I5a_FilterRF[index-1].Code_Lu_index[uVal]-1 );
    }

    /*  adapt IR_FreqPtr vs LO 
        1:                  LO< 200MHz
        2: 200MHz =<LO<600MHz
        3: 600MHz =<LO<1GHz 
    */
    if(err == TM_OK)
    {
        if (pObj->uLO < 200000000)
        {
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IR_Cal_byte_3__IR_FreqPtr, 0x01, Bus_NoRead);            
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
        }
        else if (pObj->uLO < 600000000)
        {
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IR_Cal_byte_3__IR_FreqPtr, 0x02, Bus_NoRead);            
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
        }
        else
        {
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IR_Cal_byte_3__IR_FreqPtr, 0x03, Bus_NoRead);            
           tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
        }
    }
    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_AdaptICP                                         */
/*                                                                            */
/* DESCRIPTION: Overrides ICP.                                                */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_AdaptICP(
    pTDA182I5aObject_t   pObj,   /* I: Driver object */
    UInt8              uadc_vtune,     /* I: adc_vtune */
    UInt8 uVCO_select   /* I: VCO_select */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt8 uMinor=0, uMajor=0;
    UInt8 vco_Adc_digital_icp[3][8] = \
    { \
        {\
          TDA182I5a_cp_cursel_300_uA, \
          TDA182I5a_cp_cursel_420_uA, \
          TDA182I5a_cp_cursel_420_uA, \
          TDA182I5a_cp_cursel_580_uA, \
          TDA182I5a_cp_cursel_800_uA, \
          TDA182I5a_cp_cursel_1100_uA, \
          TDA182I5a_cp_cursel_1100_uA, \
          TDA182I5a_cp_cursel_1100_uA \
        }, \
        { \
          TDA182I5a_cp_cursel_300_uA, \
          TDA182I5a_cp_cursel_300_uA, \
          TDA182I5a_cp_cursel_420_uA, \
          TDA182I5a_cp_cursel_420_uA, \
          TDA182I5a_cp_cursel_800_uA, \
          TDA182I5a_cp_cursel_800_uA, \
          TDA182I5a_cp_cursel_1100_uA, \
          TDA182I5a_cp_cursel_1100_uA \
        }, \
        { \
          TDA182I5a_cp_cursel_300_uA, \
          TDA182I5a_cp_cursel_300_uA, \
          TDA182I5a_cp_cursel_420_uA, \
          TDA182I5a_cp_cursel_420_uA, \
          TDA182I5a_cp_cursel_800_uA, \
          TDA182I5a_cp_cursel_800_uA, \
          TDA182I5a_cp_cursel_1100_uA, \
          TDA182I5a_cp_cursel_1100_uA \
        }
    };
    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_AdaptICP(0x%08X)", pObj->tUnitW);

    if (pObj->pStandard->cp_cursel_algo == TDA182I5a_cp_cursel_Analog)
    {
        /*  Analog Standards
          vtune_adc     cp_cursel 
            0              0 :60u 
            1              0: 60u 
            2              0: 60u 
            3              0: 60u
            4              0: 60u
            5              0: 60u 
            6              1: 150u 
            7              1: 150u 

        */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Charge_pump_byte__cpleak0, (uadc_vtune < 6 )? 0x01 : 0x00 , Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Charge_pump_byte__cp_cursel, (uadc_vtune < 6 )? 0 : 1, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    else if (pObj->pStandard->cp_cursel_algo == TDA182I5a_cp_cursel_Digital)      
    {
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_ID_byte_3__Minor_rev, &uMinor, Bus_None );
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_ID_byte_3__Major_rev, &uMajor, Bus_None );
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Charge_pump_byte__cpleak0, 0x00 , Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Charge_pump_byte__cp_cursel, vco_Adc_digital_icp[uVCO_select][uadc_vtune], Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_SetPLL                                              */
/*                                                                            */
/* DESCRIPTION: Set the PLL in manual mode                                    */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
extern tmErrorCode_t
iTDA182I5a_SetPLL(
    pTDA182I5aObject_t   pObj    /* I: Driver object */
)
{
    tmErrorCode_t err = TM_OK;

    /* Algorithm that calculates N, K */
    UInt32 N_int = 0;
    UInt32 K_int = 0;
    /* SUB_LO prog */
    UInt8 Nsub=0, Nsub_floor=0, Nsub_ceiling=0;
    UInt32 Nsub_err_mhz_floor=0, Nsub_err__mhz_ceiling=0;
    Bool out_of_16Mhz[TDA182I5a_StandardMode_Max] = { False, False, False, False, False, False, False, False, False, False, 
        False, False, True, True, True, True, True, False, False };

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_SetPLL(0x%08X)", pObj->tUnitW);

    if(err == TM_OK)
    {
        /* Calculate N & K values of the PLL */
        err = iTDA182I5a_CalculateNIntKInt(pObj, &N_int, &K_int);
    }

    /* Affect registers map without writing to IC ( only Nfrac High and medium part , Low in HW) */
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Sigma_delta_byte_2__LO_Frac_2, (UInt8)((K_int >> 16) & 0xFF), Bus_None);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Sigma_delta_byte_3__LO_Frac_1, (UInt8)((K_int >> 8) & 0xFF), Bus_None);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }

    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Sigma_delta_byte_1__LO_Int, (UInt8)(N_int & 0xFF), Bus_None);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }

    if(err == TM_OK)
    {
        /* Write bytes Sigma_delta_byte_1 to Sigma_delta_byte_3  */
        err = iTDA182I5a_WriteRegMap(pObj, gTDA182I5a_Reg_Sigma_delta_byte_1.Address, TDA182I5a_REG_DATA_LEN(gTDA182I5a_Reg_Sigma_delta_byte_1, gTDA182I5a_Reg_Sigma_delta_byte_3));
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }

    /* program SUBLO  fct ( LO ) :  calculate Nsub to keep Fsub as close as possible of 16 Mhz*/
    Nsub_floor = (UInt8)(pObj->uLO / 16000000);
    Nsub_ceiling = Nsub_floor + 1;

    // check value to avoid div by zero
    if(Nsub_floor == 0)
    {
        err = TDA182I5a_ERR_BAD_PARAMETER;
    }

    if( err == TM_OK )
    {
        Nsub_err_mhz_floor = (pObj->uLO / Nsub_floor ) - 16000000 ;
        Nsub_err__mhz_ceiling = 16000000 - (pObj->uLO / Nsub_ceiling);
        Nsub = (Nsub_err_mhz_floor < Nsub_err__mhz_ceiling ? Nsub_floor : Nsub_ceiling);
    }

    /* set AGC_freq to 62.500 */
    err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Reference_Byte__AGC_freq, TDA182I5a_AGC_freq_62d5_kHz, Bus_NoRead);


    /* exlude subLO too near 16Mhz in range of 10 Khz (if resquested in the current standard) */
    if( err == TM_OK && out_of_16Mhz[pObj->StandardMode] == True )
    {
        if (Nsub_err_mhz_floor  < 10000 || Nsub_err__mhz_ceiling < 10000)
        {
            //Nsub = Nsub +1;
            /* set AGC_freq to 62.750 */
            err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Reference_Byte__AGC_freq, TDA182I5a_AGC_freq_62d745_kHz, Bus_NoRead);

            tmDBGPRINTEx(DEBUGLVL_TERSE, "LO %d PAL SubLO change : %d vs %d ", pObj->uLO, pObj->uLO / Nsub, pObj->uLO / (Nsub-1));
        }
        /* STANDARD NTSC : exlude subLO  16.120 Mhz +/- 20 Khz */
        else if (pObj->StandardMode == TDA182I5a_ANLG_MN)
        {
            if ( pObj->uLO / Nsub > 16100000 &&  pObj->uLO / Nsub < 16140000)
            {
                //Nsub = Nsub +1;
                /* set AGC_freq to 62.750 */
                err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Reference_Byte__AGC_freq, TDA182I5a_AGC_freq_62d745_kHz, Bus_NoRead);

                tmDBGPRINTEx(DEBUGLVL_TERSE, "LO %d NTSC SubLO change : %d vs %d ", pObj->uLO, pObj->uLO / Nsub, pObj->uLO / (Nsub-1));
            }
        }
    }

    if(err == TM_OK)
    {   /* SUBLO_prog = Nsub - 2 */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Sublo_byte__SUBLO_prog, Nsub - 2, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }
    /* launch synchro */
    if(err == TM_OK)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Sigma_prog_byte__Update_prg, 0x01, Bus_NoRead);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
        err = err | iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_Sigma_prog_byte__Update_prg, 0x00, Bus_None);
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_CalculateNIntKInt                                   */
/*                                                                            */
/* DESCRIPTION: Calculate PLL N & K values                                    */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
static tmErrorCode_t
iTDA182I5a_CalculateNIntKInt(
    pTDA182I5aObject_t   pObj,    /* I: Driver object */
    UInt32* NInt, 
    UInt32* KInt
)
{
    tmErrorCode_t err = TM_OK;

    /* Algorithm that calculates N_K */
    UInt32 N_K_prog = 0;

    /* Algorithm that calculates N, K corrected */
    UInt32 Nprime = 0;
    UInt32 KforceK0_1 = 0;
    UInt32 K2msb = 0;
    UInt32 N0 = 0;
    UInt32 Nm1 = 0;

    /* Calculate N_K_Prog */
    N_K_prog = (pObj->uFVCO * 128) / 125;

    /* Calculate N & K corrected values */
    Nprime = N_K_prog & 0xFF0000;

    /* Force LSB to 1 */
    KforceK0_1 = 2*(((N_K_prog - Nprime) << 7) / 2) + 1;

    /* Check MSB bit around 2 */
    K2msb = KforceK0_1 >> 21;
    if (K2msb < 1)
    {
        N0 = 1;
    }
    else
    {
        if (K2msb >= 3)
        {
            N0 = 1;
        }
        else
        {
            N0 = 0;
        }
    }
    if (K2msb < 1)
    {
        Nm1 = 1;
    }
    else
    {
        Nm1 = 0;
    }

    /* Calculate N */
    *NInt = (2 * ((Nprime >> 16) - Nm1) + N0) - 128;

    /* Calculate K */
    if (K2msb < 1)
    {
        *KInt = KforceK0_1 + (2 << 21);
    }
    else
    {
        if (K2msb >= 3)
        {
            *KInt = KforceK0_1 - (2 << 21);
        }
        else
        {
            *KInt = KforceK0_1;
        }
    }

    /* Force last 7 bits of K_int to 0x5D, as the IC is doing for spurs optimization */
    *KInt &= 0xFFFFFF80;
    /* *KInt |= 0x5D; done by HW */

    return err;
}
/*============================================================================*/
/* FUNCTION:    iTDA182I5a_Adapt_vco_swingctrl                                 */
/*                                                                            */
/* DESCRIPTION: Adapt VCO swing vs adc vtune                                  */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
extern tmErrorCode_t
iTDA182I5a_Adapt_vco_swingctrl(
    pTDA182I5aObject_t   pObj,   /* I: Driver object */
    UInt8  adc_vtune,
    UInt8   VCO_select
)
{
    tmErrorCode_t err = TM_OK;
    UInt8 uMinor=0, uMajor=0;
    UInt8 vco_swingctrl_Adc[3][8] = \
    { \
        {\
          TDA182I5a_VCO_swingctrl_240_mV, \
          TDA182I5a_VCO_swingctrl_280_mV, \
          TDA182I5a_VCO_swingctrl_280_mV, \
          TDA182I5a_VCO_swingctrl_320_mV, \
          TDA182I5a_VCO_swingctrl_360_mV, \
          TDA182I5a_VCO_swingctrl_360_mV, \
          TDA182I5a_VCO_swingctrl_360_mV, \
          TDA182I5a_VCO_swingctrl_360_mV \
        }, \
        { \
          TDA182I5a_VCO_swingctrl_240_mV, \
          TDA182I5a_VCO_swingctrl_240_mV, \
          TDA182I5a_VCO_swingctrl_280_mV, \
          TDA182I5a_VCO_swingctrl_320_mV, \
          TDA182I5a_VCO_swingctrl_360_mV, \
          TDA182I5a_VCO_swingctrl_400_mV, \
          TDA182I5a_VCO_swingctrl_400_mV, \
          TDA182I5a_VCO_swingctrl_400_mV \
        }, \
        { \
          TDA182I5a_VCO_swingctrl_200_mV, \
          TDA182I5a_VCO_swingctrl_240_mV, \
          TDA182I5a_VCO_swingctrl_240_mV, \
          TDA182I5a_VCO_swingctrl_240_mV, \
          TDA182I5a_VCO_swingctrl_360_mV, \
          TDA182I5a_VCO_swingctrl_360_mV, \
          TDA182I5a_VCO_swingctrl_360_mV, \
          TDA182I5a_VCO_swingctrl_380_mV \
        }
    };
    if(err == TM_OK)
    {
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_ID_byte_3__Minor_rev, &uMinor, Bus_None );
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_ID_byte_3__Major_rev, &uMajor, Bus_None );
  	    err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_VCO_cal_byte_2__VCO_swingctrl, vco_swingctrl_Adc[VCO_select][adc_vtune], Bus_NoRead);
	    tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
    }

    return err;
}
/*============================================================================*/
/* FUNCTION:    iTDA182I5a_Force_vco_currentctrl                               */
/*                                                                            */
/* DESCRIPTION: Force lvco instead of auto cal VCO_Ampl                       */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
extern tmErrorCode_t
iTDA182I5a_Force_vco_currentctrl(
    pTDA182I5aObject_t   pObj,   /* I: Driver object */
    UInt8  adc_vtune,
    UInt8   VCO_select
)
{
    tmErrorCode_t err = TM_OK;
    UInt8 vcocur_Adc[3][8] = \
    { \
        {\
          8, \
          9, \
          10, \
          11, \
          13, \
          14, \
          15, \
          15 \
        }, \
        { \
          7, \
          7, \
          8, \
          11, \
          12, \
          12, \
          13, \
          13 \
        }, \
        { \
          5, \
          5, \
          6, \
          9, \
          10, \
          11, \
          12, \
          12 \
        }
    };

    err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_VCO_cal_byte_1__VCOampl_force_cur, 0x01, Bus_None);
  	err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_VCO_cal_byte_1__VCO_currentctrl, vcocur_Adc[VCO_select][adc_vtune], Bus_NoRead);
	tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));

    return err;
}
/*============================================================================*/
/* FUNCTION:    iTDA182I5a_MSMLaunch                                              */
/*                                                                            */
/* DESCRIPTION: clear IRQ, launch MSM                                         */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_MSMLaunch(
    pTDA182I5aObject_t   pObj,   /* I: Driver object */
    UInt8           uCalMask /* I: list of Cal to permform */
)
{
    tmErrorCode_t   err = TM_OK;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_SetMSM(0x%08X)", pObj->tUnitW);

    if(err == TM_OK)
    {
		/* clear all IRQ */
		err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_IRQ_clear, 0xFE, Bus_NoRead);
		tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Write(0x%08X) failed.", pObj->tUnitW));
	}       
    
    if(err == TM_OK)
    {
        /* Set state machine and Launch it */
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_MSM_byte_1, uCalMask, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_MSM_byte_2__MSM_Launch, 0x01, Bus_None);
        err = iTDA182I5a_WriteRegMap(pObj, gTDA182I5a_Reg_MSM_byte_1.Address, 0x02);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_WriteRegMap(0x%08X) failed.", pObj->tUnitW));
        err = err | iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_MSM_byte_2__MSM_Launch, 0x00, Bus_None);
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_WaitIRQ                                             */
/*                                                                            */
/* DESCRIPTION: Wait the IRQ to trigger                                       */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_WaitIRQ(
    pTDA182I5aObject_t   pObj,       /* I: Driver object */
    UInt32              timeOut,    /* I: timeout */
    UInt32              waitStep   /* I: wait step */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt32          counter = timeOut/waitStep; /* Wait max timeOut/waitStep ms */
    UInt8           uIRQ = 0;
    Bool            bIRQTriggered = False;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_WaitIRQ(0x%08X)", pObj->tUnitW);

    while(err == TM_OK && (counter--)>0)
    {
        err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_IRQ_status__IRQ_status, &uIRQ, Bus_RW);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Read(0x%08X) failed.", pObj->tUnitW));

        if(err == TM_OK && uIRQ == 1)
        {
            bIRQTriggered = True;
            break;
        }

        if(counter)
        {
            err = iTDA182I5a_Wait(pObj, waitStep);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_Wait(0x%08X) failed.", pObj->tUnitW));
        }
    }

    if(err == TM_OK && bIRQTriggered == False)
    {
        err = TDA182I5a_ERR_NOT_READY;
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_Write                                               */
/*                                                                            */
/* DESCRIPTION: Writes in TDA182I5a hardware                                   */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_Write(
    pTDA182I5aObject_t           pObj,       /* I: Driver object */
    const TDA182I5a_BitField_t*  pBitField, /* I: Bitfield structure */
    UInt8                       uData,      /* I: Data to write */
    tmbslFrontEndBusAccess_t                eBusAccess  /* I: Access to bus */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt8           RegAddr = 0;
    UInt32          DataLen = 1;
    UInt8           RegData = 0;
    pUInt8          pRegData = Null;
    UInt32          RegMask = 0;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_Write(0x%08X)", pObj->tUnitW);

    if(pBitField == Null)
    {
        err = TDA182I5a_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        /* Set Register Address */
        RegAddr = pBitField->Address;

        if(RegAddr < TDA182I5a_REG_MAP_NB_BYTES)
        {
            pRegData = (UInt8 *)(&(pObj->RegMap)) + RegAddr;
        }
        else
        {
            pRegData = &RegData;
        }

        if( (eBusAccess&Bus_NoRead) == False && P_SIO_READ_VALID)
        {
            /* Read data from TDA182I5a */
            err = P_SIO_READ(pObj->tUnitW, TDA182I5a_REG_ADD_SZ, &RegAddr, DataLen, pRegData);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "IO_Read(0x%08X, 1, 0x%02X, %d) failed.", pObj->tUnitW, RegAddr, DataLen));
        }

        if(err == TM_OK)
        {
            RegMask = ( (1 << pBitField->WidthInBits) - 1);
            /* Limit uData to WidthInBits */
            uData &= RegMask;

            /* Set Data */
            RegMask = RegMask << pBitField->PositionInBits;
            *pRegData &= (UInt8)(~RegMask);
            *pRegData |= uData << pBitField->PositionInBits;

            if( (eBusAccess&Bus_NoWrite) == False && P_SIO_WRITE_VALID)
            {
                /* Write data to TDA182I5a */
                err = P_SIO_WRITE(pObj->tUnitW, TDA182I5a_REG_ADD_SZ, &RegAddr, DataLen, pRegData);
                tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "IO_Write(0x%08X, 1, 0x%02X, %d) failed.", pObj->tUnitW, RegAddr, DataLen));
            }
        }
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_Read                                                */
/*                                                                            */
/* DESCRIPTION: Reads in TDA182I5a hardware                                    */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_Read(
    pTDA182I5aObject_t           pObj,       /* I: Driver object */
    const TDA182I5a_BitField_t*  pBitField, /* I: Bitfield structure */
    UInt8*                      puData,     /* I: Data to read */
    tmbslFrontEndBusAccess_t                eBusAccess  /* I: Access to bus */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt8           RegAddr = 0;
    UInt32          DataLen = 1;
    UInt8           RegData = 0;
    pUInt8          pRegData = Null;
    UInt32          RegMask = 0;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_Read(0x%08X)", pObj->tUnitW);

    if(pBitField == Null)
    {
        err = TDA182I5a_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK)
    {
        /* Set Register Address */
        RegAddr = pBitField->Address;

        if(RegAddr < TDA182I5a_REG_MAP_NB_BYTES)
        {
            pRegData = (UInt8 *)(&(pObj->RegMap)) + RegAddr;
        }
        else
        {
            pRegData = &RegData;
        }

        if( (eBusAccess&Bus_NoRead) == False && P_SIO_READ_VALID)
        {
            /* Read data from TDA182I5a */
            err = P_SIO_READ(pObj->tUnitW, TDA182I5a_REG_ADD_SZ, &RegAddr, DataLen, pRegData);
            tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "IO_Read(0x%08X, 1, 0x%02X, %d) failed.", pObj->tUnitW, RegAddr, DataLen));
        }

        if(err == TM_OK && puData != Null)
        {
            /* Copy Raw Data */
            *puData = *pRegData;

            /* Get Data */
            RegMask = ( (1 << pBitField->WidthInBits) - 1) << pBitField->PositionInBits;
            *puData &= (UInt8)RegMask;
            *puData = (*puData) >> pBitField->PositionInBits;
        }
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_WriteRegMap                                         */
/*                                                                            */
/* DESCRIPTION: Writes driver RegMap cached data to TDA182I5a hardware.        */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_WriteRegMap(
    pTDA182I5aObject_t   pObj,       /* I: Driver object */
    UInt8               uAddress,   /* I: Data to write */
    UInt32              uWriteLen   /* I: Number of data to write */
)
{
    tmErrorCode_t   err = TM_OK;
    pUInt8          pRegData = Null;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_WriteRegMap(0x%08X)", pObj->tUnitW);

    if( uAddress < TDA182I5a_REG_MAP_NB_BYTES &&
        (uAddress + uWriteLen) <= TDA182I5a_REG_MAP_NB_BYTES )
    {
        pRegData = (UInt8 *)(&(pObj->RegMap)) + uAddress;
    }
    else
    {
        err = TDA182I5a_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK && P_SIO_WRITE_VALID)
    {
        /* Write data to TDA182I5a */
        err = P_SIO_WRITE(pObj->tUnitW, TDA182I5a_REG_ADD_SZ, &uAddress, uWriteLen, pRegData);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "IO_Write(0x%08X, 1, 0x%02X, %d) failed.", pObj->tUnitW, uAddress, uWriteLen));
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_ReadRegMap                                          */
/*                                                                            */
/* DESCRIPTION: Reads driver RegMap cached data from TDA182I5a hardware.       */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_ReadRegMap(
    pTDA182I5aObject_t   pObj,       /* I: Driver object */
    UInt8               uAddress,   /* I: Data to read */
    UInt32              uReadLen    /* I: Number of data to read */
)
{
    tmErrorCode_t   err = TM_OK;
    pUInt8          pRegData = Null;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_ReadRegMap(0x%08X)", pObj->tUnitW);

    if( uAddress < TDA182I5a_REG_MAP_NB_BYTES &&
       (uAddress + uReadLen) <= TDA182I5a_REG_MAP_NB_BYTES )
    {
        pRegData = (UInt8 *)(&(pObj->RegMap)) + uAddress;
    }
    else
    {
        err = TDA182I5a_ERR_BAD_PARAMETER;
    }

    if(err == TM_OK && P_SIO_READ_VALID)
    {
        /* Read data from TDA182I5a */
        err = P_SIO_READ(pObj->tUnitW, TDA182I5a_REG_ADD_SZ, &uAddress, uReadLen, pRegData);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "IO_Read(0x%08X, 1, 0x%02X, %d) failed.", pObj->tUnitW, uAddress, uReadLen));
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_Wait                                                */
/*                                                                            */
/* DESCRIPTION: Waits for requested time.                                     */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t 
iTDA182I5a_Wait(
    pTDA182I5aObject_t   pObj,   /* I: Driver object */
    UInt32              Time    /* I: time to wait for */
)
{
    tmErrorCode_t   err = TDA182I5a_ERR_NULL_CONTROLFUNC;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_Wait(0x%08X)", pObj->tUnitW);

    if(P_STIME_WAIT_VALID)
    {
        /* Wait Time ms */
        err = P_STIME_WAIT(pObj->tUnitW, Time);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "TIME_Wait(0x%08X, %d) failed.", pObj->tUnitW, Time));
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_PowerSavingMode                                     */
/*                                                                            */
/* DESCRIPTION: set registers according  the  PowerSavingMode                 */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t 
iTDA182I5a_PowerSavingMode(
    pTDA182I5aObject_t   pObj,   /* I: Driver object */
    TDA182I5aPowerSavingMode_t  PowerSavingMode    /* I: time to wait for */
)
{
    tmErrorCode_t   err = TDA182I5a_ERR_NULL_CONTROLFUNC;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_Wait(0x%08X)", pObj->tUnitW);

	if (PowerSavingMode == TDA182I5aPowerSavingMode_Digital_nominal)
	{
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_LNA, TDA182I5a_PSM_LNA_n10_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_AGC2, TDA182I5a_PSM_AGC2_n11_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_Det2, TDA182I5a_PSM_Det2_n2_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__PSM_RF_LPF, TDA182I5a_PSM_RF_LPF_n7_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_LoMixer, TDA182I5a_PSM_LoMixer_3_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__PSM_Lodriver, TDA182I5a_PSM_Lodriver_n6_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__PSM_Mixer, TDA182I5a_PSM_Mixer_n3_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__LOdiv4_Boost, TDA182I5a_LOdiv4_Boost_0_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__Loch_curr_boost, TDA182I5a_Loch_curr_boost_0, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__PSM_Ifpoly, TDA182I5a_PSM_Ifpoly_0_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__PSM_IFfilter, TDA182I5a_PSM_IFfilter_n8d9_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__PSM_IFLPF, TDA182I5a_PSM_IFLPF_n4d9_mA, Bus_None);
	}
	else if (PowerSavingMode == TDA182I5aPowerSavingMode_Analog_nominal)
	{
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_LNA, TDA182I5a_PSM_LNA_n10_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_AGC2, TDA182I5a_PSM_AGC2_n11_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_Det2, TDA182I5a_PSM_Det2_n2_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__PSM_RF_LPF, TDA182I5a_PSM_RF_LPF_0_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_LoMixer, TDA182I5a_PSM_LoMixer_3_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__PSM_Lodriver, TDA182I5a_PSM_Lodriver_n6_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__PSM_Mixer, TDA182I5a_PSM_Mixer_n3_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__LOdiv4_Boost, TDA182I5a_LOdiv4_Boost_0_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__Loch_curr_boost, TDA182I5a_Loch_curr_boost_0, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__PSM_Ifpoly, TDA182I5a_PSM_Ifpoly_n3d2_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__PSM_IFfilter, TDA182I5a_PSM_IFfilter_n8d9_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__PSM_IFLPF, TDA182I5a_PSM_IFLPF_0_mA, Bus_None);
	}
	else if (PowerSavingMode == TDA182I5aPowerSavingMode_QAM_nominal)
	{
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_LNA, TDA182I5a_PSM_LNA_n10_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_AGC2, TDA182I5a_PSM_AGC2_0_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_Det2, TDA182I5a_PSM_Det2_n1_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__PSM_RF_LPF, TDA182I5a_PSM_RF_LPF_0_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_LoMixer, TDA182I5a_PSM_LoMixer_3_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__PSM_Lodriver, TDA182I5a_PSM_Lodriver_n6_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__PSM_Mixer, TDA182I5a_PSM_Mixer_n3_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__LOdiv4_Boost, TDA182I5a_LOdiv4_Boost_0_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__Loch_curr_boost, TDA182I5a_Loch_curr_boost_0, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__PSM_Ifpoly, TDA182I5a_PSM_Ifpoly_n3d2_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__PSM_IFfilter, TDA182I5a_PSM_IFfilter_n8d9_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__PSM_IFLPF, TDA182I5a_PSM_IFLPF_n4d9_mA, Bus_None);
	}
	else if (PowerSavingMode == TDA182I5aPowerSavingMode_ATSC_nominal)
	{
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_LNA, TDA182I5a_PSM_LNA_n10_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_AGC2, TDA182I5a_PSM_AGC2_n11_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_Det2, TDA182I5a_PSM_Det2_n2_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__PSM_RF_LPF, TDA182I5a_PSM_RF_LPF_0_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_LoMixer, TDA182I5a_PSM_LoMixer_3_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__PSM_Lodriver, TDA182I5a_PSM_Lodriver_n6_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__PSM_Mixer, TDA182I5a_PSM_Mixer_0_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__LOdiv4_Boost, TDA182I5a_LOdiv4_Boost_1d8_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__Loch_curr_boost, TDA182I5a_Loch_curr_boost_0, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__PSM_Ifpoly, TDA182I5a_PSM_Ifpoly_0_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__PSM_IFfilter, TDA182I5a_PSM_IFfilter_0_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__PSM_IFLPF, TDA182I5a_PSM_IFLPF_0_mA, Bus_None);
    }
	else if (PowerSavingMode == TDA182I5aPowerSavingMode_DTMB_nominal)
    {
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_LNA, TDA182I5a_PSM_LNA_n10_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_AGC2, TDA182I5a_PSM_AGC2_n11_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_Det2, TDA182I5a_PSM_Det2_n2_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__PSM_RF_LPF, TDA182I5a_PSM_RF_LPF_n7_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_1__PSM_LoMixer, TDA182I5a_PSM_LoMixer_3_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__PSM_Lodriver, TDA182I5a_PSM_Lodriver_n6_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__PSM_Mixer, TDA182I5a_PSM_Mixer_n3_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__LOdiv4_Boost, TDA182I5a_LOdiv4_Boost_0_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__Loch_curr_boost, TDA182I5a_Loch_curr_boost_0, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_3__PSM_Ifpoly, TDA182I5a_PSM_Ifpoly_n3d2_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__PSM_IFfilter, TDA182I5a_PSM_IFfilter_n8d9_mA, Bus_None);
        err = iTDA182I5a_Write(pObj, &gTDA182I5a_Reg_PowerSavingMode_byte_2__PSM_IFLPF, TDA182I5a_PSM_IFLPF_n4d9_mA, Bus_None);
    }
    if(err == TM_OK)
    {
        /* Write gTDA182I5a_Reg_PowerSavingMode_byte_1 to gTDA182I5a_Reg_PowerSavingMode_byte_3  Registers */
        err = iTDA182I5a_WriteRegMap(pObj, gTDA182I5a_Reg_PowerSavingMode_byte_1.Address, TDA182I5a_REG_DATA_LEN(gTDA182I5a_Reg_PowerSavingMode_byte_1, gTDA182I5a_Reg_PowerSavingMode_byte_3));
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "iTDA182I5a_WriteRegMap(0x%08X) failed.", pObj->tUnitW));
    }
    if(err == TM_OK)
    {
        pObj->curPowerSavingMode = PowerSavingMode;
    }


	return err;
}
/*============================================================================*/
/* FUNCTION:    iTDA182I5a_GetIdentity                                         */
/*                                                                            */
/* DESCRIPTION:  returns  Tuner Identity                                      */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/*============================================================================*/
tmErrorCode_t 
iTDA182I5a_GetIdentity(
    pTDA182I5aObject_t   pObj,   /* I: Driver object */
    UInt16*  puIdentity    /* O: numerical identity  */
)
{
    tmErrorCode_t   err = TM_OK;
    UInt8               ID_byte_1 = 0;
    UInt8               ID_byte_2 = 0;

    err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_ID_byte_1__Ident_1, &ID_byte_1, Bus_None);
    err = iTDA182I5a_Read(pObj, &gTDA182I5a_Reg_ID_byte_2__Ident_2, &ID_byte_2, Bus_None);
    /* Construct Identity */
    *puIdentity = (ID_byte_1 << 8) | ID_byte_2;
    return err;
}

#ifdef _TVFE_IMPLEMENT_MUTEX

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_MutexAcquire:                                       */
/*                                                                            */
/* DESCRIPTION: Acquires driver mutex.                                        */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_MutexAcquire(
    pTDA182I5aObject_t   pObj,
    UInt32              timeOut
)
{
    tmErrorCode_t   err = TDA182I5a_ERR_NULL_CONTROLFUNC;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_MutexAcquire(0x%08X)", pObj->tUnitW);

    if(P_SMUTEX_ACQUIRE_VALID && P_MUTEX_VALID)
    {
        err = P_SMUTEX_ACQUIRE(P_MUTEX, timeOut);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "Mutex_Acquire(0x%08X, %d) failed.", pObj->tUnitW, timeOut));
    }

    return err;
}

/*============================================================================*/
/* FUNCTION:    iTDA182I5a_MutexRelease:                                       */
/*                                                                            */
/* DESCRIPTION: Releases driver mutex.                                        */
/*                                                                            */
/* RETURN:      TM_OK if no error                                             */
/*                                                                            */
/* NOTES:                                                                     */
/*============================================================================*/
tmErrorCode_t
iTDA182I5a_MutexRelease(
    pTDA182I5aObject_t   pObj
)
{
    tmErrorCode_t   err = TDA182I5a_ERR_NULL_CONTROLFUNC;

    tmDBGPRINTEx(DEBUGLVL_INOUT, "iTDA182I5a_MutexRelease(0x%08X)", pObj->tUnitW);

    if(P_SMUTEX_RELEASE_VALID && P_MUTEX_VALID)
    {
        err = P_SMUTEX_RELEASE(P_MUTEX);
        tmASSERTExT(err, TM_OK, (DEBUGLVL_ERROR, "Mutex_Release(0x%08X) failed.", pObj->tUnitW));
    }

    return err;
}
#endif




